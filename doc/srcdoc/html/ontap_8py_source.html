<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libStorageMgmt: ontap.py Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>ontap.py</h1><a href="ontap_8py.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html">00001</a> <span class="comment"># Copyright (C) 2011-2014 Red Hat, Inc.</span>
<a name="l00002"></a>00002 <span class="comment"># This library is free software; you can redistribute it and/or</span>
<a name="l00003"></a>00003 <span class="comment"># modify it under the terms of the GNU Lesser General Public</span>
<a name="l00004"></a>00004 <span class="comment"># License as published by the Free Software Foundation; either</span>
<a name="l00005"></a>00005 <span class="comment"># version 2.1 of the License, or any later version.</span>
<a name="l00006"></a>00006 <span class="comment">#</span>
<a name="l00007"></a>00007 <span class="comment"># This library is distributed in the hope that it will be useful,</span>
<a name="l00008"></a>00008 <span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00009"></a>00009 <span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00010"></a>00010 <span class="comment"># Lesser General Public License for more details.</span>
<a name="l00011"></a>00011 <span class="comment">#</span>
<a name="l00012"></a>00012 <span class="comment"># You should have received a copy of the GNU Lesser General Public</span>
<a name="l00013"></a>00013 <span class="comment"># License along with this library; If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00014"></a>00014 <span class="comment">#</span>
<a name="l00015"></a>00015 <span class="comment"># Author: tasleson</span>
<a name="l00016"></a>00016 <span class="comment">#         Gris Ge &lt;fge@redhat.com&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="keyword">import</span> os
<a name="l00019"></a>00019 <span class="keyword">import</span> urlparse
<a name="l00020"></a>00020 <span class="keyword">import</span> copy
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">import</span> na
<a name="l00023"></a>00023 <span class="keyword">from</span> lsm <span class="keyword">import</span> (Volume, FileSystem, FsSnapshot, NfsExport,
<a name="l00024"></a>00024                  AccessGroup, System, Capabilities, Disk, Pool,
<a name="l00025"></a>00025                  IStorageAreaNetwork, INfs, LsmError, ErrorNumber, JobStatus,
<a name="l00026"></a>00026                  md5, VERSION, common_urllib2_error_handler,
<a name="l00027"></a>00027                  search_property, TargetPort)
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">#Maps na to lsm, this is expected to expand over time.</span>
<a name="l00030"></a><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html#aadb400b8a668c6e5be926e91fcb4200a">00030</a> e_map = {
<a name="l00031"></a>00031     na.Filer.ENOSPC: ErrorNumber.NOT_ENOUGH_SPACE,
<a name="l00032"></a>00032     na.Filer.ENO_SUCH_VOLUME: ErrorNumber.NOT_FOUND_VOLUME,
<a name="l00033"></a>00033     na.Filer.ESIZE_TOO_LARGE: ErrorNumber.NOT_ENOUGH_SPACE,
<a name="l00034"></a>00034     na.Filer.ENOSPACE: ErrorNumber.NOT_ENOUGH_SPACE,
<a name="l00035"></a>00035     na.Filer.ENO_SUCH_FS: ErrorNumber.NOT_FOUND_FS,
<a name="l00036"></a>00036     na.Filer.EAPILICENSE: ErrorNumber.NOT_LICENSED,
<a name="l00037"></a>00037     na.Filer.EFSDOESNOTEXIST: ErrorNumber.NOT_FOUND_FS,
<a name="l00038"></a>00038     na.Filer.EFSOFFLINE: ErrorNumber.NO_SUPPORT_ONLINE_CHANGE,
<a name="l00039"></a>00039     na.Filer.EFSNAMEINVALID: ErrorNumber.INVALID_ARGUMENT,
<a name="l00040"></a>00040     na.Filer.ESERVICENOTLICENSED: ErrorNumber.NOT_LICENSED,
<a name="l00041"></a>00041     na.Filer.ECLONE_LICENSE_EXPIRED: ErrorNumber.NOT_LICENSED,
<a name="l00042"></a>00042     na.Filer.ECLONE_NOT_LICENSED: ErrorNumber.NOT_LICENSED,
<a name="l00043"></a>00043     na.Filer.EINVALID_ISCSI_NAME: ErrorNumber.INVALID_ARGUMENT,
<a name="l00044"></a>00044     na.Filer.ETIMEOUT: ErrorNumber.TIMEOUT,
<a name="l00045"></a>00045     na.Filer.EUNKNOWN: ErrorNumber.PLUGIN_BUG,
<a name="l00046"></a>00046     na.Filer.EDUPE_VOLUME_PATH: ErrorNumber.NAME_CONFLICT,
<a name="l00047"></a>00047     na.Filer.ENAVOL_NAME_DUPE: ErrorNumber.NAME_CONFLICT,
<a name="l00048"></a>00048     na.Filer.ECLONE_NAME_EXISTS: ErrorNumber.NAME_CONFLICT
<a name="l00049"></a>00049 }
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html#a0b0e7f6834bf81adca550d71ebee5994">00052</a> <span class="keyword">def </span><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html#a0b0e7f6834bf81adca550d71ebee5994">error_map</a>(oe):
<a name="l00053"></a>00053     <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00054"></a>00054 <span class="stringliteral">    Maps a ontap error code to a lsm error code.</span>
<a name="l00055"></a>00055 <span class="stringliteral">    Returns a tuple containing error code and text.</span>
<a name="l00056"></a>00056 <span class="stringliteral">    &quot;&quot;&quot;</span>
<a name="l00057"></a>00057     <span class="keywordflow">if</span> oe.errno <span class="keywordflow">in</span> e_map:
<a name="l00058"></a>00058         <span class="keywordflow">return</span> e_map[oe.errno], oe.reason
<a name="l00059"></a>00059     <span class="keywordflow">else</span>:
<a name="l00060"></a>00060         <span class="keywordflow">return</span> ErrorNumber.PLUGIN_BUG, \
<a name="l00061"></a>00061             oe.reason + <span class="stringliteral">&quot; (vendor error code= &quot;</span> + str(oe.errno) + <span class="stringliteral">&quot;)&quot;</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html#a702ca8dd7bff375ce7d54e9b76d9b5b4">00064</a> <span class="keyword">def </span><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html#a702ca8dd7bff375ce7d54e9b76d9b5b4">handle_ontap_errors</a>(method):
<a name="l00065"></a>00065     <span class="keyword">def </span>na_wrapper(*args, **kwargs):
<a name="l00066"></a>00066         <span class="keywordflow">try</span>:
<a name="l00067"></a>00067             <span class="keywordflow">return</span> method(*args, **kwargs)
<a name="l00068"></a>00068         <span class="keywordflow">except</span> LsmError:
<a name="l00069"></a>00069             <span class="keywordflow">raise</span>
<a name="l00070"></a>00070         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> oe:
<a name="l00071"></a>00071             error_code, error_msg = error_map(oe)
<a name="l00072"></a>00072             <span class="keywordflow">raise</span> LsmError(error_code, error_msg)
<a name="l00073"></a>00073         <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:
<a name="l00074"></a>00074             common_urllib2_error_handler(e)
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <span class="keywordflow">return</span> na_wrapper
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="namespaceplugin_1_1ontap_1_1ontap.html#a303162498786f29a8cbea6f2d2ed795a">00079</a> _INIT_TYPE_CONV = {
<a name="l00080"></a>00080     <span class="stringliteral">&apos;iscsi&apos;</span>: AccessGroup.INIT_TYPE_ISCSI_IQN,
<a name="l00081"></a>00081     <span class="stringliteral">&apos;fcp&apos;</span>: AccessGroup.INIT_TYPE_WWPN,
<a name="l00082"></a>00082     <span class="stringliteral">&apos;mixed&apos;</span>: AccessGroup.INIT_TYPE_ISCSI_WWPN_MIXED,
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="keyword">def </span>_na_init_type_to_lsm(na_ag):
<a name="l00087"></a>00087     <span class="keywordflow">if</span> <span class="stringliteral">&apos;initiator-group-type&apos;</span> <span class="keywordflow">in</span> na_ag:
<a name="l00088"></a>00088         <span class="keywordflow">if</span> na_ag[<span class="stringliteral">&apos;initiator-group-type&apos;</span>] <span class="keywordflow">in</span> _INIT_TYPE_CONV.keys():
<a name="l00089"></a>00089             <span class="keywordflow">return</span> _INIT_TYPE_CONV[na_ag[<span class="stringliteral">&apos;initiator-group-type&apos;</span>]]
<a name="l00090"></a>00090         <span class="keywordflow">else</span>:
<a name="l00091"></a>00091             <span class="keywordflow">return</span> AccessGroup.INIT_TYPE_OTHER
<a name="l00092"></a>00092     <span class="keywordflow">return</span> AccessGroup.INIT_TYPE_UNKNOWN
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">def </span>_lsm_vol_to_na_vol_path(vol):
<a name="l00096"></a>00096     <span class="keywordflow">return</span> vol.id
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html">00099</a> <span class="keyword">class </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html">Ontap</a>(IStorageAreaNetwork, INfs):
<a name="l00100"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a0c9bb99fe6f2629ea01c712b3275e960">00100</a>     TMO_CONV = 1000.0
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     (SS_JOB, SPLIT_JOB) = (<span class="stringliteral">&apos;ontap-ss-file-restore&apos;</span>, <span class="stringliteral">&apos;ontap-clone-split&apos;</span>)
<a name="l00103"></a>00103 
<a name="l00104"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a276977bc923bd7ccecd5ade6113c1bb2">00104</a>     VOLUME_PREFIX = <span class="stringliteral">&apos;/vol&apos;</span>
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a68279512ed5102011608099572396098">00106</a>     NA_VOL_STATUS_TO_LSM = {
<a name="l00107"></a>00107         <span class="stringliteral">&apos;offline&apos;</span>: Pool.STATUS_STOPPED,
<a name="l00108"></a>00108         <span class="stringliteral">&apos;online&apos;</span>: Pool.STATUS_OK,
<a name="l00109"></a>00109         <span class="stringliteral">&apos;restricted&apos;</span>: Pool.STATUS_OTHER,
<a name="l00110"></a>00110         <span class="stringliteral">&apos;unknown&apos;</span>: Pool.STATUS_UNKNOWN,
<a name="l00111"></a>00111         <span class="stringliteral">&apos;creating&apos;</span>: Pool.STATUS_INITIALIZING,
<a name="l00112"></a>00112         <span class="stringliteral">&apos;failed&apos;</span>: Pool.STATUS_ERROR,
<a name="l00113"></a>00113         <span class="stringliteral">&apos;partial&apos;</span>: Pool.STATUS_ERROR,
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a850eefd08eea1f2db6b1ed327ddc147c">00117</a>     NA_VOL_STATUS_TO_LSM_STATUS_INFO = {
<a name="l00118"></a>00118         <span class="stringliteral">&apos;partial&apos;</span>: <span class="stringliteral">&apos;all the disks in the volume are not available.&apos;</span>,
<a name="l00119"></a>00119         <span class="stringliteral">&apos;restricted&apos;</span>: <span class="stringliteral">&apos;volume is restricted to protocol accesses&apos;</span>,
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="comment"># strip size: http://www.netapp.com/us/media/tr-3001.pdf</span>
<a name="l00123"></a>00123     _STRIP_SIZE = 4096
<a name="l00124"></a>00124     _OPT_IO_SIZE = 65536
<a name="l00125"></a>00125 
<a name="l00126"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac775ee34451fdfa742b318538164070e">00126</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac775ee34451fdfa742b318538164070e">__init__</a>(self):
<a name="l00127"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">00127</a>         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a> = <span class="keywordtype">None</span>
<a name="l00128"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">00128</a>         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a> = <span class="keywordtype">None</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     @handle_ontap_errors
<a name="l00131"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a7131889558640ed9099d19a92c210403">00131</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a7131889558640ed9099d19a92c210403">plugin_register</a>(self, uri, password, timeout, flags=0):
<a name="l00132"></a>00132         ssl = <span class="keyword">False</span>
<a name="l00133"></a>00133         u = urlparse.urlparse(uri)
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         <span class="keywordflow">if</span> u.scheme.lower() == <span class="stringliteral">&apos;ontap+ssl&apos;</span>:
<a name="l00136"></a>00136             ssl = <span class="keyword">True</span>
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a> = na.Filer(u.hostname, u.username, password,
<a name="l00139"></a>00139                           timeout / Ontap.TMO_CONV, ssl)
<a name="l00140"></a>00140         <span class="comment">#Smoke test</span>
<a name="l00141"></a>00141         i = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.system_info()
<a name="l00142"></a>00142         <span class="comment">#TODO Get real filer status</span>
<a name="l00143"></a>00143         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a> = System(i[<span class="stringliteral">&apos;system-id&apos;</span>], i[<span class="stringliteral">&apos;system-name&apos;</span>],
<a name="l00144"></a>00144                                System.STATUS_OK, <span class="stringliteral">&apos;&apos;</span>)
<a name="l00145"></a>00145         <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.validate()
<a name="l00146"></a>00146 
<a name="l00147"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aefd1ea4c24b87882967a65225461f518">00147</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aefd1ea4c24b87882967a65225461f518">time_out_set</a>(self, ms, flags=0):
<a name="l00148"></a>00148         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.timeout = int(ms / Ontap.TMO_CONV)
<a name="l00149"></a>00149 
<a name="l00150"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aca86a2f78fedd0654bfb8ed9627145a4">00150</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aca86a2f78fedd0654bfb8ed9627145a4">time_out_get</a>(self, flags=0):
<a name="l00151"></a>00151         <span class="keywordflow">return</span> int(self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.timeout * Ontap.TMO_CONV)
<a name="l00152"></a>00152 
<a name="l00153"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac15cc98fbe534cd818261e9346de60c9">00153</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac15cc98fbe534cd818261e9346de60c9">plugin_unregister</a>(self, flags=0):
<a name="l00154"></a>00154         <span class="keywordflow">pass</span>
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     @staticmethod
<a name="l00157"></a>00157     <span class="keyword">def </span>_create_vpd(sn):
<a name="l00158"></a>00158         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00159"></a>00159 <span class="stringliteral">        Construct the vpd83 for this lun</span>
<a name="l00160"></a>00160 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00161"></a>00161         <span class="keywordflow">return</span> <span class="stringliteral">&quot;60a98000&quot;</span> + <span class="stringliteral">&apos;&apos;</span>.join([<span class="stringliteral">&quot;%02x&quot;</span> % ord(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> sn])
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     @staticmethod
<a name="l00164"></a>00164     <span class="keyword">def </span>_lsm_lun_name(path_name):
<a name="l00165"></a>00165         <span class="keywordflow">return</span> os.path.basename(path_name)
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     <span class="keyword">def </span>_lun(self, l):
<a name="l00168"></a>00168         block_size = int(l[<span class="stringliteral">&apos;block-size&apos;</span>])
<a name="l00169"></a>00169         num_blocks = int(l[<span class="stringliteral">&apos;size&apos;</span>]) / block_size
<a name="l00170"></a>00170         pool_id = <span class="stringliteral">&quot;/&quot;</span>.join(l[<span class="stringliteral">&apos;path&apos;</span>].split(<span class="stringliteral">&apos;/&apos;</span>)[0:3])
<a name="l00171"></a>00171         vol_id = l[<span class="stringliteral">&apos;path&apos;</span>]
<a name="l00172"></a>00172         vol_name = os.path.basename(vol_id)
<a name="l00173"></a>00173         admin_state = Volume.ADMIN_STATE_ENABLED
<a name="l00174"></a>00174         <span class="keywordflow">if</span> l[<span class="stringliteral">&apos;online&apos;</span>] == <span class="stringliteral">&apos;false&apos;</span>:
<a name="l00175"></a>00175             admin_state = Volume.ADMIN_STATE_DISABLED
<a name="l00176"></a>00176 
<a name="l00177"></a>00177         <span class="keywordflow">return</span> Volume(vol_id, vol_name,
<a name="l00178"></a>00178                       Ontap._create_vpd(l[<span class="stringliteral">&apos;serial-number&apos;</span>]), block_size,
<a name="l00179"></a>00179                       num_blocks, admin_state, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id, pool_id)
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="keyword">def </span>_vol(self, v, pools=None):
<a name="l00182"></a>00182         pool_name = v[<span class="stringliteral">&apos;containing-aggregate&apos;</span>]
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         <span class="keywordflow">if</span> pools <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l00185"></a>00185             pools = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a2db5ded4a3129c2d49b739f6bbcb4cbf">pools</a>()
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="keywordflow">for</span> p <span class="keywordflow">in</span> pools:
<a name="l00188"></a>00188             <span class="keywordflow">if</span> p.name == pool_name:
<a name="l00189"></a>00189                 <span class="keywordflow">return</span> FileSystem(v[<span class="stringliteral">&apos;uuid&apos;</span>], v[<span class="stringliteral">&apos;name&apos;</span>], int(v[<span class="stringliteral">&apos;size-total&apos;</span>]),
<a name="l00190"></a>00190                                   int(v[<span class="stringliteral">&apos;size-available&apos;</span>]), p.id,
<a name="l00191"></a>00191                                   self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id)
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     @staticmethod
<a name="l00194"></a>00194     <span class="keyword">def </span>_ss(s):
<a name="l00195"></a>00195         <span class="comment">#If we use the newer API we can use the uuid instead of this fake</span>
<a name="l00196"></a>00196         <span class="comment">#md5 one</span>
<a name="l00197"></a>00197         <span class="keywordflow">return</span> FsSnapshot(md5(s[<span class="stringliteral">&apos;name&apos;</span>] + s[<span class="stringliteral">&apos;access-time&apos;</span>]), s[<span class="stringliteral">&apos;name&apos;</span>],
<a name="l00198"></a>00198                           s[<span class="stringliteral">&apos;access-time&apos;</span>])
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     _NA_DISK_TYPE_TO_LSM = {
<a name="l00201"></a>00201         <span class="stringliteral">&apos;ATA&apos;</span>: Disk.TYPE_ATA,
<a name="l00202"></a>00202         <span class="stringliteral">&apos;BSAS&apos;</span>: Disk.TYPE_SATA,
<a name="l00203"></a>00203         <span class="stringliteral">&apos;EATA&apos;</span>: Disk.TYPE_ATA,
<a name="l00204"></a>00204         <span class="stringliteral">&apos;FCAL&apos;</span>: Disk.TYPE_FC,
<a name="l00205"></a>00205         <span class="stringliteral">&apos;FSAS&apos;</span>: Disk.TYPE_NL_SAS,
<a name="l00206"></a>00206         <span class="stringliteral">&apos;LUN&apos;</span>: Disk.TYPE_OTHER,
<a name="l00207"></a>00207         <span class="stringliteral">&apos;MSATA&apos;</span>: Disk.TYPE_SATA,
<a name="l00208"></a>00208         <span class="stringliteral">&apos;SAS&apos;</span>: Disk.TYPE_SAS,
<a name="l00209"></a>00209         <span class="stringliteral">&apos;SATA&apos;</span>: Disk.TYPE_SATA,
<a name="l00210"></a>00210         <span class="stringliteral">&apos;SCSI&apos;</span>: Disk.TYPE_SCSI,
<a name="l00211"></a>00211         <span class="stringliteral">&apos;SSD&apos;</span>: Disk.TYPE_SSD,
<a name="l00212"></a>00212         <span class="stringliteral">&apos;XATA&apos;</span>: Disk.TYPE_ATA,
<a name="l00213"></a>00213         <span class="stringliteral">&apos;XSAS&apos;</span>: Disk.TYPE_SAS,
<a name="l00214"></a>00214         <span class="stringliteral">&apos;unknown&apos;</span>: Disk.TYPE_UNKNOWN,
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     @staticmethod
<a name="l00218"></a>00218     <span class="keyword">def </span>_disk_type_of(na_disk):
<a name="l00219"></a>00219         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00220"></a>00220 <span class="stringliteral">        Convert na_disk[&apos;effective-disk-type&apos;] to LSM disk type.</span>
<a name="l00221"></a>00221 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00222"></a>00222         na_disk_type = na_disk[<span class="stringliteral">&apos;effective-disk-type&apos;</span>]
<a name="l00223"></a>00223         <span class="keywordflow">if</span> na_disk_type <span class="keywordflow">in</span> Ontap._NA_DISK_TYPE_TO_LSM.keys():
<a name="l00224"></a>00224             <span class="keywordflow">return</span> Ontap._NA_DISK_TYPE_TO_LSM[na_disk_type]
<a name="l00225"></a>00225         <span class="keywordflow">return</span> Disk.TYPE_UNKNOWN
<a name="l00226"></a>00226 
<a name="l00227"></a>00227     @staticmethod
<a name="l00228"></a>00228     <span class="keyword">def </span>_disk_id(na_disk):
<a name="l00229"></a>00229         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00230"></a>00230 <span class="stringliteral">        The md5sum of na_disk[&apos;disk-uid&apos;]</span>
<a name="l00231"></a>00231 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00232"></a>00232         <span class="keywordflow">return</span> md5(na_disk[<span class="stringliteral">&apos;disk-uid&apos;</span>])
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     @staticmethod
<a name="l00235"></a>00235     <span class="keyword">def </span>_status_of_na_disk(na_disk):
<a name="l00236"></a>00236         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00237"></a>00237 <span class="stringliteral">        Retrieve Disk.status from NetApp ONTAP disk-detail-info.</span>
<a name="l00238"></a>00238 <span class="stringliteral">        TODO: API document does not provide enough explaination.</span>
<a name="l00239"></a>00239 <span class="stringliteral">              Need lab test to verify.</span>
<a name="l00240"></a>00240 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00241"></a>00241         status = 0
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         <span class="keywordflow">if</span> <span class="stringliteral">&apos;raid-state&apos;</span> <span class="keywordflow">in</span> na_disk:
<a name="l00244"></a>00244             rs = na_disk[<span class="stringliteral">&apos;raid-state&apos;</span>]
<a name="l00245"></a>00245             <span class="keywordflow">if</span> rs == <span class="stringliteral">&quot;broken&quot;</span>:
<a name="l00246"></a>00246                 <span class="keywordflow">if</span> na_disk[<span class="stringliteral">&apos;broken-details&apos;</span>] == <span class="stringliteral">&apos;admin removed&apos;</span> <span class="keywordflow">or</span> \
<a name="l00247"></a>00247                    na_disk[<span class="stringliteral">&apos;broken-details&apos;</span>] == <span class="stringliteral">&apos;admin failed&apos;</span>:
<a name="l00248"></a>00248                     status |= Disk.STATUS_REMOVED
<a name="l00249"></a>00249                 <span class="keywordflow">elif</span> na_disk[<span class="stringliteral">&apos;broken-details&apos;</span>] == <span class="stringliteral">&apos;admin testing&apos;</span>:
<a name="l00250"></a>00250                     status |= Disk.STATUS_STOPPED | \
<a name="l00251"></a>00251                         Disk.STATUS_MAINTENANCE_MODE
<a name="l00252"></a>00252                 <span class="keywordflow">else</span>:
<a name="l00253"></a>00253                     status |= Disk.STATUS_ERROR
<a name="l00254"></a>00254             <span class="keywordflow">elif</span> rs == <span class="stringliteral">&quot;unknown&quot;</span>:
<a name="l00255"></a>00255                 status |= Disk.STATUS_UNKNOWN
<a name="l00256"></a>00256             <span class="keywordflow">elif</span> rs == <span class="stringliteral">&apos;zeroing&apos;</span>:
<a name="l00257"></a>00257                 status |= Disk.STATUS_INITIALIZING | Disk.STATUS_SPARE_DISK
<a name="l00258"></a>00258             <span class="keywordflow">elif</span> rs == <span class="stringliteral">&apos;reconstructing&apos;</span> <span class="keywordflow">or</span> rs == <span class="stringliteral">&apos;copy&apos;</span>:
<a name="l00259"></a>00259                 <span class="comment"># &quot;reconstructing&apos; should be a pool status, not disk status.</span>
<a name="l00260"></a>00260                 <span class="comment"># disk under reconstructing should be considered as OK.</span>
<a name="l00261"></a>00261                 status |= Disk.STATUS_OK | Disk.STATUS_RECONSTRUCT
<a name="l00262"></a>00262             <span class="keywordflow">elif</span> rs == <span class="stringliteral">&apos;spare&apos;</span>:
<a name="l00263"></a>00263                 <span class="keywordflow">if</span> <span class="stringliteral">&apos;is-zeroed&apos;</span> <span class="keywordflow">in</span> na_disk <span class="keywordflow">and</span> na_disk[<span class="stringliteral">&apos;is-zeroed&apos;</span>] == <span class="stringliteral">&apos;true&apos;</span>:
<a name="l00264"></a>00264                     status |= Disk.STATUS_OK | Disk.STATUS_SPARE_DISK
<a name="l00265"></a>00265                 <span class="keywordflow">else</span>:
<a name="l00266"></a>00266                     <span class="comment"># If spare disk is not zerored, it will be automaticlly</span>
<a name="l00267"></a>00267                     <span class="comment"># zeroed before assigned to aggregate.</span>
<a name="l00268"></a>00268                     <span class="comment"># Hence we consider non-zeroed spare disks as stopped</span>
<a name="l00269"></a>00269                     <span class="comment"># spare disks.</span>
<a name="l00270"></a>00270                     status |= Disk.STATUS_STOPPED | Disk.STATUS_SPARE_DISK
<a name="l00271"></a>00271             <span class="keywordflow">elif</span> rs == <span class="stringliteral">&apos;present&apos;</span>:
<a name="l00272"></a>00272                 status |= Disk.STATUS_OK
<a name="l00273"></a>00273             <span class="keywordflow">elif</span> rs == <span class="stringliteral">&apos;partner&apos;</span>:
<a name="l00274"></a>00274                 <span class="comment"># Before we have good way to connect two controller,</span>
<a name="l00275"></a>00275                 <span class="comment"># we have to mark partner disk as OTHER</span>
<a name="l00276"></a>00276                 <span class="keywordflow">return</span> Disk.STATUS_OTHER
<a name="l00277"></a>00277 
<a name="l00278"></a>00278         <span class="keywordflow">if</span> <span class="stringliteral">&apos;is-prefailed&apos;</span> <span class="keywordflow">in</span> na_disk <span class="keywordflow">and</span> na_disk[<span class="stringliteral">&apos;is-prefailed&apos;</span>] == <span class="stringliteral">&apos;true&apos;</span>:
<a name="l00279"></a>00279             status |= Disk.STATUS_STOPPING
<a name="l00280"></a>00280 
<a name="l00281"></a>00281         <span class="keywordflow">if</span> <span class="stringliteral">&apos;is-offline&apos;</span> <span class="keywordflow">in</span> na_disk <span class="keywordflow">and</span> na_disk[<span class="stringliteral">&apos;is-offline&apos;</span>] == <span class="stringliteral">&apos;true&apos;</span>:
<a name="l00282"></a>00282             status |= Disk.STATUS_ERROR
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         <span class="keywordflow">if</span> <span class="stringliteral">&apos;aggregate&apos;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> na_disk:
<a name="l00285"></a>00285             <span class="comment"># All free disks are automatically marked as spare disks. They</span>
<a name="l00286"></a>00286             <span class="comment"># could easily convert to data or parity disk without any</span>
<a name="l00287"></a>00287             <span class="comment"># explicit command.</span>
<a name="l00288"></a>00288             status |= Disk.STATUS_FREE
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         <span class="keywordflow">if</span> status == 0:
<a name="l00291"></a>00291             status = Disk.STATUS_UNKNOWN
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <span class="keywordflow">return</span> status
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     @staticmethod
<a name="l00296"></a>00296     <span class="keyword">def </span>_status_info_of_na_disk(na_disk):
<a name="l00297"></a>00297         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00298"></a>00298 <span class="stringliteral">        Provide more explainaion in Disk.status_info.</span>
<a name="l00299"></a>00299 <span class="stringliteral">        TODO: API document does not provide enough explaination.</span>
<a name="l00300"></a>00300 <span class="stringliteral">              Need lab test to verify.</span>
<a name="l00301"></a>00301 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00302"></a>00302         status_info = <span class="stringliteral">&apos;&apos;</span>
<a name="l00303"></a>00303         <span class="keywordflow">if</span> <span class="stringliteral">&apos;raid-state&apos;</span> <span class="keywordflow">in</span> na_disk:
<a name="l00304"></a>00304             rs = na_disk[<span class="stringliteral">&apos;raid-state&apos;</span>]
<a name="l00305"></a>00305             <span class="keywordflow">if</span> rs == <span class="stringliteral">&apos;reconstructing&apos;</span>:
<a name="l00306"></a>00306                 status_info = <span class="stringliteral">&quot;Reconstruction progress: %s%%&quot;</span> %\
<a name="l00307"></a>00307                     str(na_disk[<span class="stringliteral">&apos;reconstruction-percent&apos;</span>])
<a name="l00308"></a>00308             <span class="keywordflow">if</span> <span class="stringliteral">&apos;broken-details&apos;</span> <span class="keywordflow">in</span> na_disk:
<a name="l00309"></a>00309                 status_info = na_disk[<span class="stringliteral">&apos;broken-details&apos;</span>]
<a name="l00310"></a>00310         <span class="keywordflow">return</span> status_info
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="keyword">def </span>_disk(self, d, flag):
<a name="l00313"></a>00313         status = Ontap._status_of_na_disk(d)
<a name="l00314"></a>00314         <span class="keywordflow">return</span> Disk(self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633ce37af5d9f19dde59cc773357c45f">_disk_id</a>(d), d[<span class="stringliteral">&apos;name&apos;</span>],
<a name="l00315"></a>00315                     Ontap._disk_type_of(d),
<a name="l00316"></a>00316                     int(d[<span class="stringliteral">&apos;bytes-per-sector&apos;</span>]), int(d[<span class="stringliteral">&apos;physical-blocks&apos;</span>]),
<a name="l00317"></a>00317                     status, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id)
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     @handle_ontap_errors
<a name="l00320"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4b0cedfa2577c2d650f97a8827b10733">00320</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4b0cedfa2577c2d650f97a8827b10733">volumes</a>(self, search_key=None, search_value=None, flags=0):
<a name="l00321"></a>00321         luns = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.luns_get_all()
<a name="l00322"></a>00322         <span class="keywordflow">return</span> search_property(
<a name="l00323"></a>00323             [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a8cc4b5c2f497ce908039f43cbf01c59a">_lun</a>(l) <span class="keywordflow">for</span> l <span class="keywordflow">in</span> luns], search_key, search_value)
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="comment"># This is based on NetApp ONTAP Manual pages:</span>
<a name="l00326"></a>00326     <span class="comment"># https://library.netapp.com/ecmdocs/ECMP1196890/html/man1/na_aggr.1.html</span>
<a name="l00327"></a>00327     _AGGR_RAID_STATUS_CONV = {
<a name="l00328"></a>00328         <span class="stringliteral">&apos;normal&apos;</span>: Pool.STATUS_OK,
<a name="l00329"></a>00329         <span class="stringliteral">&apos;verifying&apos;</span>: Pool.STATUS_OK | Pool.STATUS_VERIFYING,
<a name="l00330"></a>00330         <span class="stringliteral">&apos;copying&apos;</span>: Pool.STATUS_INITIALIZING,
<a name="l00331"></a>00331         <span class="stringliteral">&apos;ironing&apos;</span>: Pool.STATUS_OK | Pool.STATUS_VERIFYING,
<a name="l00332"></a>00332         <span class="stringliteral">&apos;resyncing&apos;</span>: Pool.STATUS_OK | Pool.STATUS_DEGRADED |
<a name="l00333"></a>00333         Pool.STATUS_RECONSTRUCTING,
<a name="l00334"></a>00334         <span class="stringliteral">&apos;mirror degraded&apos;</span>: Pool.STATUS_OK | Pool.STATUS_DEGRADED,
<a name="l00335"></a>00335         <span class="stringliteral">&apos;needs check&apos;</span>: Pool.STATUS_ERROR,
<a name="l00336"></a>00336         <span class="stringliteral">&apos;initializing&apos;</span>: Pool.STATUS_INITIALIZING,
<a name="l00337"></a>00337         <span class="stringliteral">&apos;growing&apos;</span>: Pool.STATUS_OK | Pool.STATUS_GROWING,
<a name="l00338"></a>00338         <span class="stringliteral">&apos;partial&apos;</span>: Pool.STATUS_ERROR,
<a name="l00339"></a>00339         <span class="stringliteral">&apos;noparity&apos;</span>: Pool.STATUS_OTHER,
<a name="l00340"></a>00340         <span class="stringliteral">&apos;degraded&apos;</span>: Pool.STATUS_OK | Pool.STATUS_DEGRADED,
<a name="l00341"></a>00341         <span class="stringliteral">&apos;reconstruct&apos;</span>: Pool.STATUS_OK | Pool.STATUS_DEGRADED |
<a name="l00342"></a>00342         Pool.STATUS_RECONSTRUCTING,
<a name="l00343"></a>00343         <span class="stringliteral">&apos;out-of-date&apos;</span>: Pool.STATUS_OTHER,
<a name="l00344"></a>00344         <span class="stringliteral">&apos;foreign&apos;</span>: Pool.STATUS_OTHER,
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     _AGGR_RAID_ST_INFO_CONV = {
<a name="l00348"></a>00348         <span class="stringliteral">&apos;copying&apos;</span>: <span class="stringliteral">&apos;The aggregate is currently the target aggregate of an&apos;</span>
<a name="l00349"></a>00349                    <span class="stringliteral">&apos;active aggr copy operation. &apos;</span>,
<a name="l00350"></a>00350         <span class="stringliteral">&apos;invalid&apos;</span>: <span class="stringliteral">&apos;The aggregate does not contain any volume and no volume&apos;</span>
<a name="l00351"></a>00351                    <span class="stringliteral">&apos;can be added to it. Typically this happens after an &apos;</span>
<a name="l00352"></a>00352                    <span class="stringliteral">&apos;aborted aggregate copy operation. &apos;</span>,
<a name="l00353"></a>00353         <span class="stringliteral">&apos;needs check&apos;</span>: <span class="stringliteral">&apos;A WAFL consistency check needs to be performed on &apos;</span>
<a name="l00354"></a>00354                        <span class="stringliteral">&apos;the aggregate. &apos;</span>,
<a name="l00355"></a>00355         <span class="stringliteral">&apos;partial&apos;</span>: <span class="stringliteral">&apos;Two or more disks are missing.&apos;</span>,
<a name="l00356"></a>00356         <span class="comment"># noparity, no document found.</span>
<a name="l00357"></a>00357         <span class="stringliteral">&apos;noparity&apos;</span>: <span class="stringliteral">&apos;NetApp ONTAP mark this aggregate as &quot;noparity&quot;. &apos;</span>,
<a name="l00358"></a>00358         <span class="comment"># out-of-data: no document found.</span>
<a name="l00359"></a>00359         <span class="stringliteral">&apos;out-of-date&apos;</span>: <span class="stringliteral">&apos;NetApp ONTAP mark this aggregate as &quot;out-of-date&quot;. &apos;</span>,
<a name="l00360"></a>00360         <span class="stringliteral">&apos;foreign&apos;</span>: <span class="stringliteral">&quot;The disks that the aggregate contains were moved to the&quot;</span>
<a name="l00361"></a>00361                    <span class="stringliteral">&quot;current node from another node. &quot;</span>
<a name="l00362"></a>00362     }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364     @staticmethod
<a name="l00365"></a>00365     <span class="keyword">def </span>_status_of_na_aggr(na_aggr):
<a name="l00366"></a>00366         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l00367"></a>00367 <span class="stringliteral">        Use aggr-info[&apos;state&apos;] and [&apos;raid-status&apos;] for Pool.status and</span>
<a name="l00368"></a>00368 <span class="stringliteral">        status_info.</span>
<a name="l00369"></a>00369 <span class="stringliteral">        Return (status, status_info)</span>
<a name="l00370"></a>00370 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l00371"></a>00371         status = 0
<a name="l00372"></a>00372         status_info = <span class="stringliteral">&apos;&apos;</span>
<a name="l00373"></a>00373         na_aggr_raid_status_list = list(
<a name="l00374"></a>00374             x.strip() <span class="keywordflow">for</span> x <span class="keywordflow">in</span> na_aggr[<span class="stringliteral">&apos;raid-status&apos;</span>].split(<span class="stringliteral">&apos;,&apos;</span>))
<a name="l00375"></a>00375         <span class="keywordflow">for</span> na_aggr_raid_status <span class="keywordflow">in</span> na_aggr_raid_status_list:
<a name="l00376"></a>00376             <span class="keywordflow">if</span> na_aggr_raid_status <span class="keywordflow">in</span> Ontap._AGGR_RAID_STATUS_CONV.keys():
<a name="l00377"></a>00377                 status |= Ontap._AGGR_RAID_STATUS_CONV[na_aggr_raid_status]
<a name="l00378"></a>00378             <span class="keywordflow">if</span> na_aggr_raid_status <span class="keywordflow">in</span> Ontap._AGGR_RAID_ST_INFO_CONV.keys():
<a name="l00379"></a>00379                 status_info += \
<a name="l00380"></a>00380                     Ontap._AGGR_RAID_ST_INFO_CONV[na_aggr_raid_status]
<a name="l00381"></a>00381 
<a name="l00382"></a>00382         <span class="comment"># Now check na_aggr[&apos;state&apos;]</span>
<a name="l00383"></a>00383         na_aggr_state = na_aggr[<span class="stringliteral">&apos;state&apos;</span>].strip()
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="keywordflow">if</span> na_aggr_state == <span class="stringliteral">&apos;online&apos;</span> <span class="keywordflow">or</span> na_aggr_state == <span class="stringliteral">&apos;creating&apos;</span>:
<a name="l00386"></a>00386             <span class="keywordflow">pass</span>
<a name="l00387"></a>00387         <span class="keywordflow">elif</span> na_aggr_state == <span class="stringliteral">&apos;offline&apos;</span>:
<a name="l00388"></a>00388             <span class="comment"># When aggr is marked as offline, the restruction is stoped.</span>
<a name="l00389"></a>00389             <span class="keywordflow">if</span> status &amp; Pool.STATUS_RECONSTRUCTING:
<a name="l00390"></a>00390                 status -= Pool.STATUS_RECONSTRUCTING
<a name="l00391"></a>00391                 status |= Pool.STATUS_DEGRADED
<a name="l00392"></a>00392             status |= Pool.STATUS_STOPPED
<a name="l00393"></a>00393         <span class="keywordflow">else</span>:
<a name="l00394"></a>00394             status_info += <span class="stringliteral">&quot;%s &quot;</span> % na_aggr_state
<a name="l00395"></a>00395 
<a name="l00396"></a>00396         <span class="keywordflow">if</span> status == 0:
<a name="l00397"></a>00397             status = Pool.STATUS_OK
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         <span class="keywordflow">return</span> status, status_info
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="keyword">def </span>_pool_from_na_aggr(self, na_aggr, flags):
<a name="l00402"></a>00402         pool_id = na_aggr[<span class="stringliteral">&apos;name&apos;</span>]
<a name="l00403"></a>00403         pool_name = na_aggr[<span class="stringliteral">&apos;name&apos;</span>]
<a name="l00404"></a>00404         total_space = int(na_aggr[<span class="stringliteral">&apos;size-total&apos;</span>])
<a name="l00405"></a>00405         free_space = int(na_aggr[<span class="stringliteral">&apos;size-available&apos;</span>])
<a name="l00406"></a>00406         system_id = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id
<a name="l00407"></a>00407         (status, status_info) = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a694bc59f497f48bd0a7d8b7b6249f4ce">_status_of_na_aggr</a>(na_aggr)
<a name="l00408"></a>00408 
<a name="l00409"></a>00409         element_type = (Pool.ELEMENT_TYPE_POOL | Pool.ELEMENT_TYPE_FS)
<a name="l00410"></a>00410 
<a name="l00411"></a>00411         <span class="comment"># The system aggregate can be used to create both FS and volumes, but</span>
<a name="l00412"></a>00412         <span class="comment"># you can&apos;t take it offline or delete it.</span>
<a name="l00413"></a>00413         <span class="keywordflow">if</span> pool_name == <span class="stringliteral">&apos;aggr0&apos;</span>:
<a name="l00414"></a>00414             element_type = element_type | Pool.ELEMENT_TYPE_SYS_RESERVED
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <span class="keywordflow">return</span> Pool(pool_id, pool_name, element_type, 0, total_space,
<a name="l00417"></a>00417                     free_space, status, status_info, system_id)
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     @staticmethod
<a name="l00420"></a>00420     <span class="keyword">def </span>_status_info_of_na_vol(na_vol):
<a name="l00421"></a>00421         na_vol_state = na_vol[<span class="stringliteral">&apos;state&apos;</span>]
<a name="l00422"></a>00422         <span class="keywordflow">if</span> na_vol_state <span class="keywordflow">in</span> Ontap.NA_VOL_STATUS_TO_LSM_STATUS_INFO.keys():
<a name="l00423"></a>00423             <span class="keywordflow">return</span> Ontap.NA_VOL_STATUS_TO_LSM_STATUS_INFO[na_vol_state]
<a name="l00424"></a>00424         <span class="keywordflow">return</span> <span class="stringliteral">&apos;&apos;</span>
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     @staticmethod
<a name="l00427"></a>00427     <span class="keyword">def </span>_pool_id_of_na_vol_name(na_vol_name):
<a name="l00428"></a>00428         <span class="keywordflow">return</span> <span class="stringliteral">&quot;%s/%s&quot;</span> % (Ontap.VOLUME_PREFIX, na_vol_name)
<a name="l00429"></a>00429 
<a name="l00430"></a>00430     <span class="keyword">def </span>_pool_from_na_vol(self, na_vol, na_aggrs, flags):
<a name="l00431"></a>00431         element_type = Pool.ELEMENT_TYPE_VOLUME
<a name="l00432"></a>00432         <span class="comment"># Thin provisioning is controled by:</span>
<a name="l00433"></a>00433         <span class="comment">#   1. NetApp Volume level:</span>
<a name="l00434"></a>00434         <span class="comment">#      &apos;guarantee&apos; option and &apos;fractional_reserve&apos; option.</span>
<a name="l00435"></a>00435         <span class="comment">#      If &apos;guarantee&apos; is &apos;file&apos;, &apos;fractional_reserve&apos; is forced to</span>
<a name="l00436"></a>00436         <span class="comment">#      be 100, we can create Thin LUN and full allocated LUN.</span>
<a name="l00437"></a>00437         <span class="comment">#      If &apos;guarantee&apos; is &apos;volume&apos; and &apos;fractional_reserve&apos; is 100, we</span>
<a name="l00438"></a>00438         <span class="comment">#      can create full LUN.</span>
<a name="l00439"></a>00439         <span class="comment">#      If &apos;guarantee&apos; is &apos;volume&apos; and &apos;fractional_reserve&apos; is less</span>
<a name="l00440"></a>00440         <span class="comment">#      than 100, we can only create thin LUN.</span>
<a name="l00441"></a>00441         <span class="comment">#      If &apos;guarantee&apos; is &apos;none&apos;, we can only create thin LUN.</span>
<a name="l00442"></a>00442         <span class="comment">#   2. NetApp LUN level:</span>
<a name="l00443"></a>00443         <span class="comment">#      If option &apos;reservation&apos; is enabled, it&apos;s a full allocated LUN</span>
<a name="l00444"></a>00444         <span class="comment">#      when parent NetApp volume allowed.</span>
<a name="l00445"></a>00445         <span class="comment">#      If option &apos;reservation&apos; is disabled, it&apos;s a thin LUN if</span>
<a name="l00446"></a>00446         <span class="comment">#      parent NetApp volume allowed.</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         <span class="keywordflow">if</span> <span class="stringliteral">&apos;space-reserve&apos;</span> <span class="keywordflow">in</span> na_vol <span class="keywordflow">and</span> \
<a name="l00449"></a>00449            <span class="stringliteral">&apos;space-reserve-enabled&apos;</span> <span class="keywordflow">in</span> na_vol <span class="keywordflow">and</span> \
<a name="l00450"></a>00450            <span class="stringliteral">&apos;reserve&apos;</span> <span class="keywordflow">in</span> na_vol <span class="keywordflow">and</span> \
<a name="l00451"></a>00451            na_vol[<span class="stringliteral">&apos;space-reserve-enabled&apos;</span>] == <span class="stringliteral">&apos;true&apos;</span>:
<a name="l00452"></a>00452             <span class="comment"># &apos;space-reserve&apos; and  &apos;space-reserve-enabled&apos; might not appear if</span>
<a name="l00453"></a>00453             <span class="comment"># the flexible volume is restricted or offline.</span>
<a name="l00454"></a>00454             <span class="keywordflow">if</span> na_vol[<span class="stringliteral">&apos;space-reserve&apos;</span>] == <span class="stringliteral">&apos;file&apos;</span>:
<a name="l00455"></a>00455                 <span class="comment"># space-reserve: &apos;file&apos; means only LUN or file marked as</span>
<a name="l00456"></a>00456                 <span class="comment"># &apos;Space Reservation: enabled&apos; will be reserve all space.</span>
<a name="l00457"></a>00457                 element_type |= Pool.ELEMENT_TYPE_VOLUME_THIN
<a name="l00458"></a>00458                 element_type |= Pool.ELEMENT_TYPE_VOLUME_FULL
<a name="l00459"></a>00459             <span class="keywordflow">elif</span> na_vol[<span class="stringliteral">&apos;space-reserve&apos;</span>] == <span class="stringliteral">&apos;volume&apos;</span>:
<a name="l00460"></a>00460                 <span class="comment"># space-reserve: &apos;volume&apos; means only LUN or file marked as</span>
<a name="l00461"></a>00461                 <span class="comment"># &apos;Space Reservation: enabled&apos; will be reserve all space.</span>
<a name="l00462"></a>00462                 <span class="keywordflow">if</span> na_vol[<span class="stringliteral">&apos;reserve&apos;</span>] == na_vol[<span class="stringliteral">&apos;reserve-required&apos;</span>]:
<a name="l00463"></a>00463                     <span class="comment"># When &apos;reserve&apos; == &apos;reserve-required&apos; it means option</span>
<a name="l00464"></a>00464                     <span class="comment"># &apos;fractional_reserve&apos; is set to 100, only with that we</span>
<a name="l00465"></a>00465                     <span class="comment"># can create full alocated LUN.</span>
<a name="l00466"></a>00466                     element_type |= Pool.ELEMENT_TYPE_VOLUME_FULL
<a name="l00467"></a>00467                 <span class="keywordflow">else</span>:
<a name="l00468"></a>00468                     element_type |= Pool.ELEMENT_TYPE_VOLUME_THIN
<a name="l00469"></a>00469             <span class="keywordflow">elif</span> na_vol[<span class="stringliteral">&apos;space-reserve&apos;</span>] == <span class="stringliteral">&apos;none&apos;</span>:
<a name="l00470"></a>00470                 element_type |= Pool.ELEMENT_TYPE_VOLUME_THIN
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         pool_name = na_vol[<span class="stringliteral">&apos;name&apos;</span>]
<a name="l00473"></a>00473         pool_id = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#accd7134aed1e90bde6ab2f0b61826011">_pool_id_of_na_vol_name</a>(na_vol[<span class="stringliteral">&apos;name&apos;</span>])
<a name="l00474"></a>00474         total_space = int(na_vol[<span class="stringliteral">&apos;size-total&apos;</span>])
<a name="l00475"></a>00475         free_space = int(na_vol[<span class="stringliteral">&apos;size-available&apos;</span>])
<a name="l00476"></a>00476         system_id = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id
<a name="l00477"></a>00477         status = Pool.STATUS_UNKNOWN
<a name="l00478"></a>00478         status_info = <span class="stringliteral">&apos;&apos;</span>
<a name="l00479"></a>00479         <span class="keywordflow">if</span> <span class="stringliteral">&apos;containing-aggregate&apos;</span> <span class="keywordflow">in</span> na_vol:
<a name="l00480"></a>00480             <span class="keywordflow">for</span> na_aggr <span class="keywordflow">in</span> na_aggrs:
<a name="l00481"></a>00481                 <span class="keywordflow">if</span> na_aggr[<span class="stringliteral">&apos;name&apos;</span>] == na_vol[<span class="stringliteral">&apos;containing-aggregate&apos;</span>]:
<a name="l00482"></a>00482                     status = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a694bc59f497f48bd0a7d8b7b6249f4ce">_status_of_na_aggr</a>(na_aggr)[0]
<a name="l00483"></a>00483                     <span class="keywordflow">if</span> <span class="keywordflow">not</span> (status &amp; Pool.STATUS_OK):
<a name="l00484"></a>00484                         status_info = <span class="stringliteral">&quot;Parrent pool &apos;%s&apos;&quot;</span> \
<a name="l00485"></a>00485                                       % na_aggr[<span class="stringliteral">&apos;name&apos;</span>]
<a name="l00486"></a>00486                     <span class="keywordflow">break</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="keywordflow">if</span> status &amp; Pool.STATUS_OK <span class="keywordflow">and</span> na_vol[<span class="stringliteral">&apos;state&apos;</span>] == <span class="stringliteral">&apos;offline&apos;</span>:
<a name="l00489"></a>00489             status = Pool.STATUS_STOPPED
<a name="l00490"></a>00490             status_info = <span class="stringliteral">&apos;Disabled by admin&apos;</span>
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="comment"># This volume should be noted that it is reserved for system</span>
<a name="l00493"></a>00493         <span class="comment"># and thus cannot be removed.</span>
<a name="l00494"></a>00494         <span class="keywordflow">if</span> pool_name == <span class="stringliteral">&apos;/vol/vol0&apos;</span>:
<a name="l00495"></a>00495             element_type |= Pool.ELEMENT_TYPE_SYS_RESERVED
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         <span class="keywordflow">return</span> Pool(pool_id, pool_name, element_type, 0, total_space,
<a name="l00498"></a>00498                     free_space, status, status_info, system_id)
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     @handle_ontap_errors
<a name="l00501"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad3b7358ada9758fe36dcf0d70c872148">00501</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad3b7358ada9758fe36dcf0d70c872148">capabilities</a>(self, system, flags=0):
<a name="l00502"></a>00502         cap = Capabilities()
<a name="l00503"></a>00503         cap.set(Capabilities.VOLUMES)
<a name="l00504"></a>00504         cap.set(Capabilities.VOLUME_CREATE)
<a name="l00505"></a>00505         cap.set(Capabilities.VOLUME_RESIZE)
<a name="l00506"></a>00506         cap.set(Capabilities.VOLUME_REPLICATE)
<a name="l00507"></a>00507         cap.set(Capabilities.VOLUME_REPLICATE_CLONE)
<a name="l00508"></a>00508         cap.set(Capabilities.VOLUME_COPY_RANGE_BLOCK_SIZE)
<a name="l00509"></a>00509         cap.set(Capabilities.VOLUME_COPY_RANGE)
<a name="l00510"></a>00510         cap.set(Capabilities.VOLUME_COPY_RANGE_CLONE)
<a name="l00511"></a>00511         cap.set(Capabilities.VOLUME_DELETE)
<a name="l00512"></a>00512         cap.set(Capabilities.VOLUME_ENABLE)
<a name="l00513"></a>00513         cap.set(Capabilities.VOLUME_DISABLE)
<a name="l00514"></a>00514         cap.set(Capabilities.VOLUME_ISCSI_CHAP_AUTHENTICATION)
<a name="l00515"></a>00515         cap.set(Capabilities.VOLUME_MASK)
<a name="l00516"></a>00516         cap.set(Capabilities.VOLUME_UNMASK)
<a name="l00517"></a>00517         cap.set(Capabilities.ACCESS_GROUPS)
<a name="l00518"></a>00518         cap.set(Capabilities.ACCESS_GROUP_CREATE_WWPN)
<a name="l00519"></a>00519         cap.set(Capabilities.ACCESS_GROUP_CREATE_ISCSI_IQN)
<a name="l00520"></a>00520         cap.set(Capabilities.ACCESS_GROUP_DELETE)
<a name="l00521"></a>00521         cap.set(Capabilities.ACCESS_GROUP_INITIATOR_ADD_WWPN)
<a name="l00522"></a>00522         cap.set(Capabilities.ACCESS_GROUP_INITIATOR_ADD_ISCSI_IQN)
<a name="l00523"></a>00523         cap.set(Capabilities.ACCESS_GROUP_INITIATOR_DELETE)
<a name="l00524"></a>00524         cap.set(Capabilities.VOLUMES_ACCESSIBLE_BY_ACCESS_GROUP)
<a name="l00525"></a>00525         cap.set(Capabilities.ACCESS_GROUPS_GRANTED_TO_VOLUME)
<a name="l00526"></a>00526         cap.set(Capabilities.VOLUME_CHILD_DEPENDENCY)
<a name="l00527"></a>00527         cap.set(Capabilities.VOLUME_CHILD_DEPENDENCY_RM)
<a name="l00528"></a>00528         cap.set(Capabilities.FS)
<a name="l00529"></a>00529         cap.set(Capabilities.FS_DELETE)
<a name="l00530"></a>00530         cap.set(Capabilities.FS_RESIZE)
<a name="l00531"></a>00531         cap.set(Capabilities.FS_CREATE)
<a name="l00532"></a>00532         cap.set(Capabilities.FS_CLONE)
<a name="l00533"></a>00533         cap.set(Capabilities.FILE_CLONE)
<a name="l00534"></a>00534         cap.set(Capabilities.FS_SNAPSHOTS)
<a name="l00535"></a>00535         cap.set(Capabilities.FS_SNAPSHOT_CREATE)
<a name="l00536"></a>00536         cap.set(Capabilities.FS_SNAPSHOT_DELETE)
<a name="l00537"></a>00537         cap.set(Capabilities.FS_SNAPSHOT_RESTORE)
<a name="l00538"></a>00538         cap.set(Capabilities.FS_CHILD_DEPENDENCY)
<a name="l00539"></a>00539         cap.set(Capabilities.FS_CHILD_DEPENDENCY_RM)
<a name="l00540"></a>00540         cap.set(Capabilities.EXPORT_AUTH)
<a name="l00541"></a>00541         cap.set(Capabilities.EXPORTS)
<a name="l00542"></a>00542         cap.set(Capabilities.EXPORT_FS)
<a name="l00543"></a>00543         cap.set(Capabilities.EXPORT_REMOVE)
<a name="l00544"></a>00544         cap.set(Capabilities.EXPORT_CUSTOM_PATH)
<a name="l00545"></a>00545         cap.set(Capabilities.TARGET_PORTS)
<a name="l00546"></a>00546         cap.set(Capabilities.DISKS)
<a name="l00547"></a>00547         cap.set(Capabilities.VOLUME_RAID_INFO)
<a name="l00548"></a>00548         cap.set(Capabilities.POOL_MEMBER_INFO)
<a name="l00549"></a>00549         <span class="keywordflow">return</span> cap
<a name="l00550"></a>00550 
<a name="l00551"></a>00551     @handle_ontap_errors
<a name="l00552"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aa10cf6df537af5edef9ebc7b1cc731db">00552</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aa10cf6df537af5edef9ebc7b1cc731db">plugin_info</a>(self, flags=0):
<a name="l00553"></a>00553         <span class="keywordflow">return</span> <span class="stringliteral">&quot;NetApp Filer support&quot;</span>, VERSION
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     @handle_ontap_errors
<a name="l00556"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aa3388294e18ca07771eaa36dee3fd5d7">00556</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aa3388294e18ca07771eaa36dee3fd5d7">disks</a>(self, search_key=None, search_value=None, flags=0):
<a name="l00557"></a>00557         disks = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.disks()
<a name="l00558"></a>00558         <span class="keywordflow">return</span> search_property(
<a name="l00559"></a>00559             [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a33d66a38c2e112ef1b9c6e0290010be1">_disk</a>(d, flags) <span class="keywordflow">for</span> d <span class="keywordflow">in</span> disks], search_key, search_value)
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     @handle_ontap_errors
<a name="l00562"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a2db5ded4a3129c2d49b739f6bbcb4cbf">00562</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a2db5ded4a3129c2d49b739f6bbcb4cbf">pools</a>(self, search_key=None, search_value=None, flags=0):
<a name="l00563"></a>00563         pools = []
<a name="l00564"></a>00564         na_aggrs = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.aggregates()
<a name="l00565"></a>00565         <span class="keywordflow">for</span> na_aggr <span class="keywordflow">in</span> na_aggrs:
<a name="l00566"></a>00566             pools.extend([self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ab066e7fe48be10ea3e8d1a8d9eb57514">_pool_from_na_aggr</a>(na_aggr, flags)])
<a name="l00567"></a>00567         na_vols = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes()
<a name="l00568"></a>00568         <span class="keywordflow">for</span> na_vol <span class="keywordflow">in</span> na_vols:
<a name="l00569"></a>00569             pools.extend([self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac2d346b6b47783f5a5bbe97bf101d8e6">_pool_from_na_vol</a>(na_vol, na_aggrs, flags)])
<a name="l00570"></a>00570         <span class="keywordflow">return</span> search_property(pools, search_key, search_value)
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     @handle_ontap_errors
<a name="l00573"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4871ed866b85a66f68d5d8bbf9bf1397">00573</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4871ed866b85a66f68d5d8bbf9bf1397">systems</a>(self, flags=0):
<a name="l00574"></a>00574         <span class="keywordflow">return</span> [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>]
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="keyword">def </span>_get_volume(self, vol_name, pool_id):
<a name="l00577"></a>00577         <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a8cc4b5c2f497ce908039f43cbf01c59a">_lun</a>(self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.luns_get_specific(pool_id, vol_name, <span class="keywordtype">None</span>)[0])
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     @handle_ontap_errors
<a name="l00580"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a720c825bce313b878e3d1839bbee6984">00580</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a720c825bce313b878e3d1839bbee6984">volume_create</a>(self, pool, volume_name, size_bytes, provisioning,
<a name="l00581"></a>00581                       flags=0):
<a name="l00582"></a>00582 
<a name="l00583"></a>00583         <span class="keywordflow">if</span> <span class="keywordflow">not</span> pool.element_type &amp; Pool.ELEMENT_TYPE_VOLUME:
<a name="l00584"></a>00584             <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT,
<a name="l00585"></a>00585                            <span class="stringliteral">&quot;Pool not suitable for creating volumes&quot;</span>)
<a name="l00586"></a>00586 
<a name="l00587"></a>00587         <span class="comment"># Even pool is full or thin only pool, we still allow user to</span>
<a name="l00588"></a>00588         <span class="comment"># create full or thin LUN in case that&apos;s what they intend to do so.</span>
<a name="l00589"></a>00589         <span class="comment"># TODO: allow user to query provising status of certain LUN. We can</span>
<a name="l00590"></a>00590         <span class="comment">#       use THIN(not effective) or FULL(not effective) to indicate</span>
<a name="l00591"></a>00591         <span class="comment">#       pool setting not allow thin/full LUN yet, user can change pool</span>
<a name="l00592"></a>00592         <span class="comment">#       setting.</span>
<a name="l00593"></a>00593         <span class="comment"># Wise user can check pool.element_type before creating full or thin</span>
<a name="l00594"></a>00594         <span class="comment"># volume.</span>
<a name="l00595"></a>00595         flag_thin = <span class="keyword">False</span>
<a name="l00596"></a>00596         <span class="keywordflow">if</span> provisioning == Volume.PROVISION_THIN:
<a name="l00597"></a>00597             flag_thin = <span class="keyword">True</span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599         na_vol_name = pool.name
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         lun_name = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_build_name(na_vol_name, volume_name)
<a name="l00602"></a>00602 
<a name="l00603"></a>00603         <span class="keywordflow">try</span>:
<a name="l00604"></a>00604             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_create(lun_name, size_bytes, flag_thin)
<a name="l00605"></a>00605         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> fe:
<a name="l00606"></a>00606             <span class="keywordflow">if</span> fe.errno == na.FilerError.EVDISK_ERROR_SIZE_TOO_LARGE:
<a name="l00607"></a>00607                 <span class="keywordflow">raise</span> LsmError(
<a name="l00608"></a>00608                     ErrorNumber.NOT_ENOUGH_SPACE,
<a name="l00609"></a>00609                     <span class="stringliteral">&quot;No enough requested free size in pool&quot;</span>)
<a name="l00610"></a>00610             <span class="keywordflow">elif</span> fe.errno == na.FilerError.EVDISK_ERROR_VDISK_EXISTS:
<a name="l00611"></a>00611                 <span class="keywordflow">raise</span> LsmError(
<a name="l00612"></a>00612                     ErrorNumber.NAME_CONFLICT,
<a name="l00613"></a>00613                     <span class="stringliteral">&quot;Requested volume name is already used by other volume&quot;</span>)
<a name="l00614"></a>00614             <span class="keywordflow">elif</span> fe.errno == na.FilerError.EVDISK_ERROR_SIZE_TOO_SMALL:
<a name="l00615"></a>00615                 <span class="comment"># Size too small should not be raised. By API defination,</span>
<a name="l00616"></a>00616                 <span class="comment"># we should create a LUN with mimun size.</span>
<a name="l00617"></a>00617                 min_size = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_min_size()
<a name="l00618"></a>00618                 <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a720c825bce313b878e3d1839bbee6984">volume_create</a>(
<a name="l00619"></a>00619                     pool, volume_name, min_size, provisioning, flags)
<a name="l00620"></a>00620             <span class="keywordflow">elif</span> fe.errno == na.FilerError.EVDISK_ERROR_NO_SUCH_VOLUME:
<a name="l00621"></a>00621                 <span class="comment"># When NetApp volume is offline, we will get this error also.</span>
<a name="l00622"></a>00622                 self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad560320f5b3b391c1697863cb80e70c2">_check_na_volume</a>(na_vol_name)
<a name="l00623"></a>00623             <span class="keywordflow">else</span>:
<a name="l00624"></a>00624                 <span class="keywordflow">raise</span>
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">#Get the information about the newly created LUN</span>
<a name="l00627"></a>00627         <span class="keywordflow">return</span> <span class="keywordtype">None</span>, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad00e813009320bbf2a995a37deee97fc">_get_volume</a>(lun_name, pool.id)
<a name="l00628"></a>00628 
<a name="l00629"></a>00629     @staticmethod
<a name="l00630"></a>00630     <span class="keyword">def </span>_vol_to_na_volume_name(volume):
<a name="l00631"></a>00631         <span class="keywordflow">return</span> os.path.dirname(_lsm_vol_to_na_vol_path(volume))[5:]
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     @handle_ontap_errors
<a name="l00634"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae3cdf39f9436c7f2bd0dfc6d372d17fb">00634</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae3cdf39f9436c7f2bd0dfc6d372d17fb">volume_delete</a>(self, volume, flags=0):
<a name="l00635"></a>00635         <span class="keywordflow">try</span>:
<a name="l00636"></a>00636             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_delete(_lsm_vol_to_na_vol_path(volume))
<a name="l00637"></a>00637         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> f_error:
<a name="l00638"></a>00638             <span class="comment"># We don&apos;t use handle_ontap_errors which use netapp</span>
<a name="l00639"></a>00639             <span class="comment"># error message which is not suitable for LSM user.</span>
<a name="l00640"></a>00640             <span class="keywordflow">if</span> f_error.errno == na.FilerError.EVDISK_ERROR_VDISK_EXPORTED:
<a name="l00641"></a>00641                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.IS_MASKED,
<a name="l00642"></a>00642                                <span class="stringliteral">&quot;Volume is masked to access group&quot;</span>)
<a name="l00643"></a>00643             <span class="keywordflow">raise</span>
<a name="l00644"></a>00644         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     @staticmethod
<a name="l00647"></a>00647     <span class="keyword">def </span>_size_kb_padded(size_bytes):
<a name="l00648"></a>00648         <span class="keywordflow">return</span> int((size_bytes / 1024) * 1.3)
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     @handle_ontap_errors
<a name="l00651"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aaafb0e081a5a7bd012d35f53b14e1e1a">00651</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aaafb0e081a5a7bd012d35f53b14e1e1a">volume_resize</a>(self, volume, new_size_bytes, flags=0):
<a name="l00652"></a>00652         <span class="keywordflow">try</span>:
<a name="l00653"></a>00653             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_resize(_lsm_vol_to_na_vol_path(volume), new_size_bytes)
<a name="l00654"></a>00654         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> fe:
<a name="l00655"></a>00655             <span class="keywordflow">if</span> fe.errno == na.FilerError.EVDISK_ERROR_SIZE_TOO_SMALL:
<a name="l00656"></a>00656                 min_size = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_min_size()
<a name="l00657"></a>00657                 <span class="keywordflow">try</span>:
<a name="l00658"></a>00658                     self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_resize(_lsm_vol_to_na_vol_path(volume),
<a name="l00659"></a>00659                                       min_size)
<a name="l00660"></a>00660                 <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> fe:
<a name="l00661"></a>00661                     <span class="keywordflow">if</span> fe.errno == na.FilerError.EVDISK_ERROR_SIZE_UNCHANGED:
<a name="l00662"></a>00662                         <span class="comment"># As requested size is not the one we are send to</span>
<a name="l00663"></a>00663                         <span class="comment"># self.f.lun_resize(), we should silently pass.</span>
<a name="l00664"></a>00664                         <span class="keywordflow">pass</span>
<a name="l00665"></a>00665                     <span class="keywordflow">else</span>:
<a name="l00666"></a>00666                         <span class="keywordflow">raise</span>
<a name="l00667"></a>00667             <span class="keywordflow">elif</span> fe.errno == na.FilerError.EVDISK_ERROR_SIZE_UNCHANGED:
<a name="l00668"></a>00668                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_STATE_CHANGE,
<a name="l00669"></a>00669                                <span class="stringliteral">&quot;Requested size is the same as current &quot;</span>
<a name="l00670"></a>00670                                <span class="stringliteral">&quot;volume size&quot;</span>)
<a name="l00671"></a>00671             <span class="keywordflow">else</span>:
<a name="l00672"></a>00672                 <span class="keywordflow">raise</span>
<a name="l00673"></a>00673         <span class="keywordflow">return</span> <span class="keywordtype">None</span>, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad00e813009320bbf2a995a37deee97fc">_get_volume</a>(_lsm_vol_to_na_vol_path(volume),
<a name="l00674"></a>00674                                       volume.pool_id)
<a name="l00675"></a>00675 
<a name="l00676"></a>00676     <span class="keyword">def </span>_check_na_volume(self, na_vol_name):
<a name="l00677"></a>00677         na_vols = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes(volume_name=na_vol_name)
<a name="l00678"></a>00678         <span class="keywordflow">if</span> len(na_vols) == 0:
<a name="l00679"></a>00679             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NOT_FOUND_POOL,
<a name="l00680"></a>00680                            <span class="stringliteral">&quot;Pool not found&quot;</span>)
<a name="l00681"></a>00681         <span class="keywordflow">elif</span> len(na_vols) == 1:
<a name="l00682"></a>00682             <span class="comment"># NetApp Volume is disabled.</span>
<a name="l00683"></a>00683             <span class="keywordflow">if</span> na_vols[0][<span class="stringliteral">&apos;state&apos;</span>] == <span class="stringliteral">&apos;offline&apos;</span>:
<a name="l00684"></a>00684                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.POOL_NOT_READY,
<a name="l00685"></a>00685                                <span class="stringliteral">&quot;Pool not ready for volume creation&quot;</span>)
<a name="l00686"></a>00686         <span class="keywordflow">else</span>:
<a name="l00687"></a>00687             <span class="keywordflow">raise</span> LsmError(ErrorNumber.PLUGIN_BUG,
<a name="l00688"></a>00688                            <span class="stringliteral">&quot;volume_create(): &quot;</span>
<a name="l00689"></a>00689                            <span class="stringliteral">&quot;Got 2 or more na_vols: %s&quot;</span> % na_vols)
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     <span class="keyword">def </span>_volume_on_aggr(self, pool, volume):
<a name="l00692"></a>00692         search = Ontap._vol_to_na_volume_name(volume)
<a name="l00693"></a>00693         contained_volumes = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.aggregate_volume_names(pool.name)
<a name="l00694"></a>00694         <span class="keywordflow">return</span> search <span class="keywordflow">in</span> contained_volumes
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     @handle_ontap_errors
<a name="l00697"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a54ffcd18c3d421dd510c033f1bcfe917">00697</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a54ffcd18c3d421dd510c033f1bcfe917">volume_replicate</a>(self, pool, rep_type, volume_src, name, flags=0):
<a name="l00698"></a>00698         <span class="comment">#At the moment we are only supporting space efficient writeable</span>
<a name="l00699"></a>00699         <span class="comment">#logical units.  Add support for the others later.</span>
<a name="l00700"></a>00700         <span class="keywordflow">if</span> rep_type != Volume.REPLICATE_CLONE:
<a name="l00701"></a>00701             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_SUPPORT, <span class="stringliteral">&quot;rep_type not supported&quot;</span>)
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="comment">#Check to see if our volume is on a pool that was passed in or that</span>
<a name="l00704"></a>00704         <span class="comment">#the pool itself is None</span>
<a name="l00705"></a>00705         <span class="keywordflow">if</span> pool <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#afceda4ae61fbc8a424396bb6a7c3ee39">_volume_on_aggr</a>(pool, volume_src):
<a name="l00706"></a>00706             <span class="comment">#Thin provision copy the logical unit</span>
<a name="l00707"></a>00707             dest = os.path.dirname(_lsm_vol_to_na_vol_path(volume_src)) + <span class="stringliteral">&apos;/&apos;</span> \
<a name="l00708"></a>00708                 + name
<a name="l00709"></a>00709             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.clone(_lsm_vol_to_na_vol_path(volume_src), dest)
<a name="l00710"></a>00710             <span class="keywordflow">return</span> <span class="keywordtype">None</span>, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad00e813009320bbf2a995a37deee97fc">_get_volume</a>(dest, volume_src.pool_id)
<a name="l00711"></a>00711         <span class="keywordflow">else</span>:
<a name="l00712"></a>00712             <span class="comment">#TODO Need to get instructions on how to provide this</span>
<a name="l00713"></a>00713             <span class="comment">#functionality</span>
<a name="l00714"></a>00714             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_SUPPORT,
<a name="l00715"></a>00715                            <span class="stringliteral">&quot;Unable to replicate volume to different pool&quot;</span>)
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     @handle_ontap_errors
<a name="l00718"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a91e16c71d64f6ff5cef2dc6d300c8550">00718</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a91e16c71d64f6ff5cef2dc6d300c8550">volume_replicate_range_block_size</a>(self, system, flags=0):
<a name="l00719"></a>00719         <span class="keywordflow">return</span> 4096
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     @handle_ontap_errors
<a name="l00722"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad3b1c179c79ff051c98baddf734513a0">00722</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad3b1c179c79ff051c98baddf734513a0">volume_replicate_range</a>(self, rep_type, volume_src, volume_dest, ranges,
<a name="l00723"></a>00723                                flags=0):
<a name="l00724"></a>00724         <span class="keywordflow">if</span> rep_type != Volume.REPLICATE_CLONE:
<a name="l00725"></a>00725             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_SUPPORT, <span class="stringliteral">&quot;rep_type not supported&quot;</span>)
<a name="l00726"></a>00726         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.clone(_lsm_vol_to_na_vol_path(volume_src),
<a name="l00727"></a>00727                      _lsm_vol_to_na_vol_path(volume_dest), <span class="keywordtype">None</span>, ranges)
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     @handle_ontap_errors
<a name="l00730"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a7dd5e96204c6df692dc9de8e6c2628d4">00730</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a7dd5e96204c6df692dc9de8e6c2628d4">volume_enable</a>(self, volume, flags=0):
<a name="l00731"></a>00731         <span class="keywordflow">try</span>:
<a name="l00732"></a>00732             <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_online(_lsm_vol_to_na_vol_path(volume))
<a name="l00733"></a>00733         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> fe:
<a name="l00734"></a>00734             <span class="keywordflow">if</span> fe.errno == na.FilerError.EVDISK_ERROR_VDISK_NOT_DISABLED:
<a name="l00735"></a>00735                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_STATE_CHANGE,
<a name="l00736"></a>00736                                <span class="stringliteral">&quot;Volume is already enabled&quot;</span>)
<a name="l00737"></a>00737             <span class="keywordflow">raise</span>
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     @handle_ontap_errors
<a name="l00740"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4800245aeca1e7f88a0725df176d87a4">00740</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4800245aeca1e7f88a0725df176d87a4">volume_disable</a>(self, volume, flags=0):
<a name="l00741"></a>00741         <span class="keywordflow">try</span>:
<a name="l00742"></a>00742             <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_offline(_lsm_vol_to_na_vol_path(volume))
<a name="l00743"></a>00743         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> fe:
<a name="l00744"></a>00744             <span class="keywordflow">if</span> fe.errno == na.FilerError.EVDISK_ERROR_VDISK_NOT_ENABLED:
<a name="l00745"></a>00745                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_STATE_CHANGE,
<a name="l00746"></a>00746                                <span class="stringliteral">&quot;Volume is already disabled&quot;</span>)
<a name="l00747"></a>00747             <span class="keywordflow">raise</span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     @handle_ontap_errors
<a name="l00750"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a11e89b0a224501a5633ff3976b26b974">00750</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a11e89b0a224501a5633ff3976b26b974">volume_mask</a>(self, access_group, volume, flags=0):
<a name="l00751"></a>00751         igroups = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroups(group_name=access_group.name)
<a name="l00752"></a>00752         <span class="keywordflow">if</span> len(igroups) != 1:
<a name="l00753"></a>00753             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NOT_FOUND_ACCESS_GROUP,
<a name="l00754"></a>00754                            <span class="stringliteral">&quot;AccessGroup %s(%d) not found&quot;</span> %
<a name="l00755"></a>00755                            (access_group.name, access_group.id))
<a name="l00756"></a>00756 
<a name="l00757"></a>00757         cur_init_ids = Ontap._initiators_in_group(igroups[0])
<a name="l00758"></a>00758         <span class="keywordflow">if</span> len(cur_init_ids) == 0:
<a name="l00759"></a>00759             <span class="keywordflow">raise</span> LsmError(
<a name="l00760"></a>00760                 ErrorNumber.EMPTY_ACCESS_GROUP,
<a name="l00761"></a>00761                 <span class="stringliteral">&quot;Refuse to do volume masking against empty access group&quot;</span>)
<a name="l00762"></a>00762         <span class="keywordflow">try</span>:
<a name="l00763"></a>00763             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_map(access_group.name, _lsm_vol_to_na_vol_path(volume))
<a name="l00764"></a>00764         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> fe:
<a name="l00765"></a>00765             <span class="keywordflow">if</span> fe.errno == na.FilerError.EVDISK_ERROR_INITGROUP_HAS_VDISK:
<a name="l00766"></a>00766                 <span class="keywordflow">raise</span> LsmError(
<a name="l00767"></a>00767                     ErrorNumber.NO_STATE_CHANGE,
<a name="l00768"></a>00768                     <span class="stringliteral">&quot;Volume is already masked to requested access group&quot;</span>)
<a name="l00769"></a>00769             <span class="keywordflow">else</span>:
<a name="l00770"></a>00770                 <span class="keywordflow">raise</span>
<a name="l00771"></a>00771         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     @handle_ontap_errors
<a name="l00774"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af7608f5de545237cfa4f0b24e82387b9">00774</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af7608f5de545237cfa4f0b24e82387b9">volume_unmask</a>(self, access_group, volume, flags=0):
<a name="l00775"></a>00775         <span class="keywordflow">try</span>:
<a name="l00776"></a>00776             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_unmap(
<a name="l00777"></a>00777                 access_group.name, _lsm_vol_to_na_vol_path(volume))
<a name="l00778"></a>00778         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> filer_error:
<a name="l00779"></a>00779             <span class="keywordflow">if</span> filer_error.errno == na.FilerError.EVDISK_ERROR_NO_SUCH_LUNMAP:
<a name="l00780"></a>00780                 <span class="keywordflow">raise</span> LsmError(
<a name="l00781"></a>00781                     ErrorNumber.NO_STATE_CHANGE,
<a name="l00782"></a>00782                     <span class="stringliteral">&quot;Volume is not masked to requested access group&quot;</span>)
<a name="l00783"></a>00783             <span class="keywordflow">else</span>:
<a name="l00784"></a>00784                 <span class="keywordflow">raise</span>
<a name="l00785"></a>00785         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     @staticmethod
<a name="l00788"></a>00788     <span class="keyword">def </span>_initiators_in_group(g):
<a name="l00789"></a>00789         rc = []
<a name="l00790"></a>00790         <span class="keywordflow">if</span> g:
<a name="l00791"></a>00791             <span class="keywordflow">if</span> <span class="stringliteral">&apos;initiators&apos;</span> <span class="keywordflow">in</span> g <span class="keywordflow">and</span> g[<span class="stringliteral">&apos;initiators&apos;</span>] <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:
<a name="l00792"></a>00792                 initiators = na.to_list(g[<span class="stringliteral">&apos;initiators&apos;</span>][<span class="stringliteral">&apos;initiator-info&apos;</span>])
<a name="l00793"></a>00793                 <span class="keywordflow">for</span> i <span class="keywordflow">in</span> initiators:
<a name="l00794"></a>00794                     rc.append(i[<span class="stringliteral">&apos;initiator-name&apos;</span>])
<a name="l00795"></a>00795         <span class="keywordflow">return</span> rc
<a name="l00796"></a>00796 
<a name="l00797"></a>00797     <span class="keyword">def </span>_access_group(self, g):
<a name="l00798"></a>00798         name = g[<span class="stringliteral">&apos;initiator-group-name&apos;</span>]
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         <span class="keywordflow">if</span> <span class="stringliteral">&apos;initiator-group-uuid&apos;</span> <span class="keywordflow">in</span> g:
<a name="l00801"></a>00801             ag_id = g[<span class="stringliteral">&apos;initiator-group-uuid&apos;</span>]
<a name="l00802"></a>00802         <span class="keywordflow">else</span>:
<a name="l00803"></a>00803             ag_id = md5(name)
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="keywordflow">return</span> AccessGroup(ag_id, name, Ontap._initiators_in_group(g),
<a name="l00806"></a>00806                            _na_init_type_to_lsm(g), self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id)
<a name="l00807"></a>00807 
<a name="l00808"></a>00808     @handle_ontap_errors
<a name="l00809"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#acc3cad80d96cc043342b7bffe05bba0c">00809</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#acc3cad80d96cc043342b7bffe05bba0c">access_groups</a>(self, search_key=None, search_value=None, flags=0):
<a name="l00810"></a>00810         groups = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroups()
<a name="l00811"></a>00811         <span class="keywordflow">return</span> search_property(
<a name="l00812"></a>00812             [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a86f704337b42df47d9ccc3fc2e90e9bc">_access_group</a>(g) <span class="keywordflow">for</span> g <span class="keywordflow">in</span> groups], search_key, search_value)
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     @handle_ontap_errors
<a name="l00815"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af63a602f74f6962c3e221f95139b6ec9">00815</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af63a602f74f6962c3e221f95139b6ec9">access_group_create</a>(self, name, init_id, init_type, system,
<a name="l00816"></a>00816                             flags=0):
<a name="l00817"></a>00817         <span class="keywordflow">if</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id != system.id:
<a name="l00818"></a>00818             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NOT_FOUND_SYSTEM,
<a name="l00819"></a>00819                            <span class="stringliteral">&quot;System %s not found&quot;</span> % system.id)
<a name="l00820"></a>00820 
<a name="l00821"></a>00821         <span class="comment"># NetApp sometimes(real hardware 8.0.2 and simulator 8.1.1) does not</span>
<a name="l00822"></a>00822         <span class="comment"># raise error for initiator conflict.</span>
<a name="l00823"></a>00823         <span class="comment">#</span>
<a name="l00824"></a>00824         <span class="comment"># Precheck for initiator conflict</span>
<a name="l00825"></a>00825         cur_lsm_groups = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#acc3cad80d96cc043342b7bffe05bba0c">access_groups</a>()
<a name="l00826"></a>00826         <span class="keywordflow">for</span> cur_lsm_group <span class="keywordflow">in</span> cur_lsm_groups:
<a name="l00827"></a>00827             <span class="keywordflow">if</span> cur_lsm_group.name == name:
<a name="l00828"></a>00828                 <span class="keywordflow">raise</span> LsmError(
<a name="l00829"></a>00829                     ErrorNumber.NAME_CONFLICT,
<a name="l00830"></a>00830                     <span class="stringliteral">&quot;Requested access group name is already used by other &quot;</span>
<a name="l00831"></a>00831                     <span class="stringliteral">&quot;access group&quot;</span>)
<a name="l00832"></a>00832             <span class="keywordflow">if</span> init_id <span class="keywordflow">in</span> cur_lsm_group.init_ids:
<a name="l00833"></a>00833                 <span class="keywordflow">raise</span> LsmError(
<a name="l00834"></a>00834                     ErrorNumber.EXISTS_INITIATOR,
<a name="l00835"></a>00835                     <span class="stringliteral">&quot;Requested initiator is already used by other &quot;</span>
<a name="l00836"></a>00836                     <span class="stringliteral">&quot;access group&quot;</span>)
<a name="l00837"></a>00837 
<a name="l00838"></a>00838         <span class="keywordflow">if</span> init_type == AccessGroup.INIT_TYPE_ISCSI_IQN:
<a name="l00839"></a>00839             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroup_create(name, <span class="stringliteral">&apos;iscsi&apos;</span>)
<a name="l00840"></a>00840         <span class="keywordflow">elif</span> init_type == AccessGroup.INIT_TYPE_WWPN:
<a name="l00841"></a>00841             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroup_create(name, <span class="stringliteral">&apos;fcp&apos;</span>)
<a name="l00842"></a>00842         <span class="keywordflow">else</span>:
<a name="l00843"></a>00843             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NO_SUPPORT,
<a name="l00844"></a>00844                            <span class="stringliteral">&quot;ONTAP only support iSCSI and FC/FCoE, but got &quot;</span>
<a name="l00845"></a>00845                            <span class="stringliteral">&quot;init_type: %d&quot;</span> % init_type)
<a name="l00846"></a>00846 
<a name="l00847"></a>00847         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroup_add_initiator(name, init_id)
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         groups = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#acc3cad80d96cc043342b7bffe05bba0c">access_groups</a>()
<a name="l00850"></a>00850         <span class="keywordflow">for</span> g <span class="keywordflow">in</span> groups:
<a name="l00851"></a>00851             <span class="keywordflow">if</span> g.name == name:
<a name="l00852"></a>00852                 <span class="keywordflow">return</span> g
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="keywordflow">raise</span> LsmError(ErrorNumber.PLUGIN_BUG,
<a name="l00855"></a>00855                        <span class="stringliteral">&quot;access_group_create(): Unable to find access group &quot;</span>
<a name="l00856"></a>00856                        <span class="stringliteral">&quot;%s just created!&quot;</span> % name)
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     @handle_ontap_errors
<a name="l00859"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aba0f6f045f87fd8f6fe322a8793e6a69">00859</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aba0f6f045f87fd8f6fe322a8793e6a69">access_group_delete</a>(self, access_group, flags=0):
<a name="l00860"></a>00860         <span class="keywordflow">try</span>:
<a name="l00861"></a>00861             <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroup_delete(access_group.name)
<a name="l00862"></a>00862         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> f_error:
<a name="l00863"></a>00863             <span class="keywordflow">if</span> f_error.errno == \
<a name="l00864"></a>00864                na.FilerError.EVDISK_ERROR_INITGROUP_MAPS_EXIST:
<a name="l00865"></a>00865                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.IS_MASKED,
<a name="l00866"></a>00866                                <span class="stringliteral">&quot;Access Group has volume masked&quot;</span>)
<a name="l00867"></a>00867             <span class="keywordflow">raise</span>
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     @handle_ontap_errors
<a name="l00870"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a9ec73fc0bf18a45d5221412927a08996">00870</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a9ec73fc0bf18a45d5221412927a08996">access_group_initiator_add</a>(self, access_group, init_id, init_type,
<a name="l00871"></a>00871                                    flags=0):
<a name="l00872"></a>00872         <span class="keywordflow">try</span>:
<a name="l00873"></a>00873             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroup_add_initiator(access_group.name, init_id)
<a name="l00874"></a>00874         <span class="keywordflow">except</span> na.FilerError <span class="keyword">as</span> oe:
<a name="l00875"></a>00875             <span class="keywordflow">if</span> oe.errno == na.FilerError.IGROUP_ALREADY_HAS_INIT:
<a name="l00876"></a>00876                 <span class="keywordflow">return</span> copy.deepcopy(access_group)
<a name="l00877"></a>00877             <span class="keywordflow">elif</span> oe.errno == na.FilerError.NO_SUCH_IGROUP:
<a name="l00878"></a>00878                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.NOT_FOUND_ACCESS_GROUP,
<a name="l00879"></a>00879                                <span class="stringliteral">&quot;AccessGroup %s(%d) not found&quot;</span> %
<a name="l00880"></a>00880                                (access_group.name, access_group.id))
<a name="l00881"></a>00881             <span class="keywordflow">else</span>:
<a name="l00882"></a>00882                 <span class="keywordflow">raise</span>
<a name="l00883"></a>00883         na_ags = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroups(access_group.name)
<a name="l00884"></a>00884         <span class="keywordflow">if</span> len(na_ags) != 1:
<a name="l00885"></a>00885             <span class="keywordflow">raise</span> LsmError(ErrorNumber.PLUGIN_BUG,
<a name="l00886"></a>00886                            <span class="stringliteral">&quot;access_group_initiator_add(): Got unexpected&quot;</span>
<a name="l00887"></a>00887                            <span class="stringliteral">&quot;(not 1) count of na_ag: %s&quot;</span> % na_ags)
<a name="l00888"></a>00888 
<a name="l00889"></a>00889         <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a86f704337b42df47d9ccc3fc2e90e9bc">_access_group</a>(na_ags[0])
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     @handle_ontap_errors
<a name="l00892"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a8919bfb998058b96205c27c05246c62d">00892</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a8919bfb998058b96205c27c05246c62d">access_group_initiator_delete</a>(self, access_group, init_id, init_type,
<a name="l00893"></a>00893                                       flags=0):
<a name="l00894"></a>00894         igroups = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroups(group_name=access_group.name)
<a name="l00895"></a>00895         <span class="keywordflow">if</span> len(igroups) != 1:
<a name="l00896"></a>00896             <span class="keywordflow">raise</span> LsmError(ErrorNumber.NOT_FOUND_ACCESS_GROUP,
<a name="l00897"></a>00897                            <span class="stringliteral">&quot;AccessGroup %s(%d) not found&quot;</span> %
<a name="l00898"></a>00898                            (access_group.name, access_group.id))
<a name="l00899"></a>00899 
<a name="l00900"></a>00900         cur_init_ids = Ontap._initiators_in_group(igroups[0])
<a name="l00901"></a>00901         <span class="keywordflow">if</span> init_id <span class="keywordflow">not</span> <span class="keywordflow">in</span> cur_init_ids:
<a name="l00902"></a>00902             <span class="keywordflow">raise</span> LsmError(
<a name="l00903"></a>00903                 ErrorNumber.NO_STATE_CHANGE,
<a name="l00904"></a>00904                 <span class="stringliteral">&quot;Initiator %s does not exist in access group %s&quot;</span> %
<a name="l00905"></a>00905                 (init_id, access_group.name))
<a name="l00906"></a>00906 
<a name="l00907"></a>00907         <span class="keywordflow">if</span> len(cur_init_ids) == 1:
<a name="l00908"></a>00908             <span class="keywordflow">raise</span> LsmError(
<a name="l00909"></a>00909                 ErrorNumber.LAST_INIT_IN_ACCESS_GROUP,
<a name="l00910"></a>00910                 <span class="stringliteral">&quot;Refuse to remove last initiator from access group&quot;</span>)
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroup_del_initiator(access_group.name, init_id)
<a name="l00913"></a>00913 
<a name="l00914"></a>00914         na_ags = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.igroups(access_group.name)
<a name="l00915"></a>00915         <span class="keywordflow">if</span> len(na_ags) != 1:
<a name="l00916"></a>00916             <span class="keywordflow">raise</span> LsmError(ErrorNumber.PLUGIN_BUG,
<a name="l00917"></a>00917                            <span class="stringliteral">&quot;access_group_initiator_add(): Got unexpected&quot;</span>
<a name="l00918"></a>00918                            <span class="stringliteral">&quot;(not 1) count of na_ag: %s&quot;</span> % na_ags)
<a name="l00919"></a>00919 
<a name="l00920"></a>00920         <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a86f704337b42df47d9ccc3fc2e90e9bc">_access_group</a>(na_ags[0])
<a name="l00921"></a>00921 
<a name="l00922"></a>00922     @handle_ontap_errors
<a name="l00923"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a0a2e95aefb436c1ed984032e3653461b">00923</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a0a2e95aefb436c1ed984032e3653461b">volumes_accessible_by_access_group</a>(self, access_group, flags=0):
<a name="l00924"></a>00924         rc = []
<a name="l00925"></a>00925 
<a name="l00926"></a>00926         <span class="keywordflow">if</span> len(access_group.init_ids):
<a name="l00927"></a>00927             luns = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_initiator_list_map_info(access_group.init_ids[0],
<a name="l00928"></a>00928                                                       access_group.name)
<a name="l00929"></a>00929             rc = [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a8cc4b5c2f497ce908039f43cbf01c59a">_lun</a>(l) <span class="keywordflow">for</span> l <span class="keywordflow">in</span> luns]
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="keywordflow">return</span> rc
<a name="l00932"></a>00932 
<a name="l00933"></a>00933     @handle_ontap_errors
<a name="l00934"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aa753a9c96673070b38e6ae79f31bd51f">00934</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aa753a9c96673070b38e6ae79f31bd51f">access_groups_granted_to_volume</a>(self, volume, flags=0):
<a name="l00935"></a>00935         groups = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.lun_map_list_info(_lsm_vol_to_na_vol_path(volume))
<a name="l00936"></a>00936         <span class="keywordflow">return</span> [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a86f704337b42df47d9ccc3fc2e90e9bc">_access_group</a>(g) <span class="keywordflow">for</span> g <span class="keywordflow">in</span> groups]
<a name="l00937"></a>00937 
<a name="l00938"></a>00938     @handle_ontap_errors
<a name="l00939"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ab61c233e2e6bb835df18d92cd38b526b">00939</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ab61c233e2e6bb835df18d92cd38b526b">iscsi_chap_auth</a>(self, init_id, in_user, in_password, out_user,
<a name="l00940"></a>00940                         out_password, flags=0):
<a name="l00941"></a>00941         <span class="keywordflow">if</span> out_user <span class="keywordflow">and</span> out_password <span class="keywordflow">and</span> \
<a name="l00942"></a>00942                 (in_user <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> in_password <span class="keywordflow">is</span> <span class="keywordtype">None</span>):
<a name="l00943"></a>00943             <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT,
<a name="l00944"></a>00944                            <span class="stringliteral">&quot;out_user and out_password only supported if &quot;</span>
<a name="l00945"></a>00945                            <span class="stringliteral">&quot;inbound is supplied&quot;</span>)
<a name="l00946"></a>00946 
<a name="l00947"></a>00947         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.iscsi_initiator_add_auth(init_id, in_user, in_password,
<a name="l00948"></a>00948                                         out_user, out_password)
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     @staticmethod
<a name="l00951"></a>00951     <span class="keyword">def </span>_rpercent(total, current):
<a name="l00952"></a>00952         p = 1 - (current / float(total))
<a name="l00953"></a>00953         p = min(int(100 * p), 100)
<a name="l00954"></a>00954         <span class="keywordflow">return</span> p
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     <span class="keyword">def </span>_restore_file_status(self, num):
<a name="l00957"></a>00957         running = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.snapshot_file_restore_num()
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         <span class="keywordflow">if</span> running:
<a name="l00960"></a>00960             running = min(num, running)
<a name="l00961"></a>00961             <span class="keywordflow">return</span> JobStatus.INPROGRESS, Ontap._rpercent(num, running), <span class="keywordtype">None</span>
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         <span class="keywordflow">return</span> JobStatus.COMPLETE, 100, <span class="keywordtype">None</span>
<a name="l00964"></a>00964 
<a name="l00965"></a>00965     <span class="keyword">def </span>_clone_split_status(self, volumes):
<a name="l00966"></a>00966         vols = volumes.split(<span class="stringliteral">&apos;,&apos;</span>)
<a name="l00967"></a>00967         current = len(vols)
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         <span class="comment">#It doesn&apos;t appear that we have a good percentage</span>
<a name="l00970"></a>00970         <span class="comment">#indicator from the clone split status...</span>
<a name="l00971"></a>00971         running = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_split_status()
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="keywordflow">for</span> v <span class="keywordflow">in</span> vols:
<a name="l00974"></a>00974             <span class="keywordflow">if</span> v <span class="keywordflow">not</span> <span class="keywordflow">in</span> running:
<a name="l00975"></a>00975                 current -= 1
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         <span class="keywordflow">if</span> <span class="keywordflow">not</span> running:
<a name="l00978"></a>00978             <span class="keywordflow">return</span> JobStatus.COMPLETE, 100, <span class="keywordtype">None</span>
<a name="l00979"></a>00979         <span class="keywordflow">else</span>:
<a name="l00980"></a>00980             <span class="keywordflow">return</span> JobStatus.INPROGRESS, \
<a name="l00981"></a>00981                 Ontap._rpercent(len(vols), current), <span class="keywordtype">None</span>
<a name="l00982"></a>00982 
<a name="l00983"></a>00983     @handle_ontap_errors
<a name="l00984"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a929de62122ccee78ed9f38cb27d894bd">00984</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a929de62122ccee78ed9f38cb27d894bd">job_status</a>(self, job_id, flags=0):
<a name="l00985"></a>00985         <span class="keywordflow">if</span> job_id <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="stringliteral">&apos;@&apos;</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> job_id:
<a name="l00986"></a>00986             <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT,
<a name="l00987"></a>00987                            <span class="stringliteral">&quot;Invalid job, missing @&quot;</span>)
<a name="l00988"></a>00988 
<a name="l00989"></a>00989         job = job_id.split(<span class="stringliteral">&apos;@&apos;</span>, 2)
<a name="l00990"></a>00990 
<a name="l00991"></a>00991         <span class="keywordflow">if</span> job[0] == Ontap.SS_JOB:
<a name="l00992"></a>00992             <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a927bc7e69b720380bfa6015e8cfcaf2f">_restore_file_status</a>(int(job[1]))
<a name="l00993"></a>00993         <span class="keywordflow">elif</span> job[0] == Ontap.SPLIT_JOB:
<a name="l00994"></a>00994             <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae3037211f8b2a8b54adc7eae20128a00">_clone_split_status</a>(job[1])
<a name="l00995"></a>00995 
<a name="l00996"></a>00996         <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT, <span class="stringliteral">&quot;Invalid job&quot;</span>)
<a name="l00997"></a>00997 
<a name="l00998"></a>00998     @handle_ontap_errors
<a name="l00999"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ab524e0814347bfaae02088afc9cb45de">00999</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ab524e0814347bfaae02088afc9cb45de">job_free</a>(self, job_id, flags=0):
<a name="l01000"></a>01000         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     @handle_ontap_errors
<a name="l01003"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a236bd85213ba394f4fd2347572a16977">01003</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a236bd85213ba394f4fd2347572a16977">fs</a>(self, search_key=None, search_value=None, flags=0):
<a name="l01004"></a>01004         volumes = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes()
<a name="l01005"></a>01005         pools = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a2db5ded4a3129c2d49b739f6bbcb4cbf">pools</a>()
<a name="l01006"></a>01006         <span class="keywordflow">return</span> search_property(
<a name="l01007"></a>01007             [self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a60773e87524197d1b3fc94383ebaad45">_vol</a>(v, pools) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> volumes], search_key, search_value)
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     @handle_ontap_errors
<a name="l01010"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a3d6ad99bdaf903dc771c3f82f94a812f">01010</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a3d6ad99bdaf903dc771c3f82f94a812f">fs_delete</a>(self, fs, flags=0):
<a name="l01011"></a>01011         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_delete(fs.name)
<a name="l01012"></a>01012 
<a name="l01013"></a>01013     @handle_ontap_errors
<a name="l01014"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a59de229f82d74c0dc6c5bb890491a06d">01014</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a59de229f82d74c0dc6c5bb890491a06d">fs_resize</a>(self, fs, new_size_bytes, flags=0):
<a name="l01015"></a>01015         diff = new_size_bytes - fs.total_space
<a name="l01016"></a>01016 
<a name="l01017"></a>01017         diff = Ontap._size_kb_padded(diff)
<a name="l01018"></a>01018         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_resize(fs.name, diff)
<a name="l01019"></a>01019         <span class="keywordflow">return</span> <span class="keywordtype">None</span>, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a60773e87524197d1b3fc94383ebaad45">_vol</a>(self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes(fs.name)[0])
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     @handle_ontap_errors
<a name="l01022"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a3524bdbbe612872536d978a2c82cf02b">01022</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a3524bdbbe612872536d978a2c82cf02b">fs_create</a>(self, pool, name, size_bytes, flags=0):
<a name="l01023"></a>01023         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_create(pool.name, name, size_bytes)
<a name="l01024"></a>01024         <span class="keywordflow">return</span> <span class="keywordtype">None</span>, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a60773e87524197d1b3fc94383ebaad45">_vol</a>(self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes(name)[0])
<a name="l01025"></a>01025 
<a name="l01026"></a>01026     @handle_ontap_errors
<a name="l01027"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a359ed1df01a4ef2fc9a4121583b7dfbc">01027</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a359ed1df01a4ef2fc9a4121583b7dfbc">fs_clone</a>(self, src_fs, dest_fs_name, snapshot=None, flags=0):
<a name="l01028"></a>01028         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_clone(src_fs.name, dest_fs_name, snapshot)
<a name="l01029"></a>01029         <span class="keywordflow">return</span> <span class="keywordtype">None</span>, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a60773e87524197d1b3fc94383ebaad45">_vol</a>(self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes(dest_fs_name)[0])
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     @staticmethod
<a name="l01032"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a236bd55a4071e212e9a839fd479c2d39">01032</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a236bd55a4071e212e9a839fd479c2d39">build_name</a>(volume_name, relative_name):
<a name="l01033"></a>01033         <span class="keywordflow">return</span> <span class="stringliteral">&quot;/vol/%s/%s&quot;</span> % (volume_name, relative_name)
<a name="l01034"></a>01034 
<a name="l01035"></a>01035     @handle_ontap_errors
<a name="l01036"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a77e22ffb0ae4c4984273f441c70deca3">01036</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a77e22ffb0ae4c4984273f441c70deca3">fs_file_clone</a>(self, fs, src_file_name, dest_file_name, snapshot=None,
<a name="l01037"></a>01037                       flags=0):
<a name="l01038"></a>01038         full_src = Ontap.build_name(fs.name, src_file_name)
<a name="l01039"></a>01039         full_dest = Ontap.build_name(fs.name, dest_file_name)
<a name="l01040"></a>01040 
<a name="l01041"></a>01041         ss = <span class="keywordtype">None</span>
<a name="l01042"></a>01042         <span class="keywordflow">if</span> snapshot:
<a name="l01043"></a>01043             ss = snapshot.name
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.clone(full_src, full_dest, ss)
<a name="l01046"></a>01046         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01047"></a>01047 
<a name="l01048"></a>01048     @handle_ontap_errors
<a name="l01049"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#afe5befabb920b55e493b9e7bf0b59920">01049</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#afe5befabb920b55e493b9e7bf0b59920">fs_snapshots</a>(self, fs, flags=0):
<a name="l01050"></a>01050         snapshots = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.snapshots(fs.name)
<a name="l01051"></a>01051         <span class="keywordflow">return</span> [Ontap._ss(s) <span class="keywordflow">for</span> s <span class="keywordflow">in</span> snapshots]
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     @handle_ontap_errors
<a name="l01054"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a7c12da3146af0006337bf4f701d27905">01054</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a7c12da3146af0006337bf4f701d27905">fs_snapshot_create</a>(self, fs, snapshot_name, flags=0):
<a name="l01055"></a>01055         <span class="comment">#We can&apos;t do files, so we will do them all</span>
<a name="l01056"></a>01056         snap = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.snapshot_create(fs.name, snapshot_name)
<a name="l01057"></a>01057         <span class="keywordflow">return</span> <span class="keywordtype">None</span>, Ontap._ss(snap)
<a name="l01058"></a>01058 
<a name="l01059"></a>01059     @handle_ontap_errors
<a name="l01060"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aabcb01babcda8c279ecaed56b8863b01">01060</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aabcb01babcda8c279ecaed56b8863b01">fs_snapshot_delete</a>(self, fs, snapshot, flags=0):
<a name="l01061"></a>01061         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.snapshot_delete(fs.name, snapshot.name)
<a name="l01062"></a>01062 
<a name="l01063"></a>01063     <span class="keyword">def </span>_ss_restore_files(self, volume_name, snapshot_name, files,
<a name="l01064"></a>01064                           restore_files):
<a name="l01065"></a>01065         <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(files)):
<a name="l01066"></a>01066             src = Ontap.build_name(volume_name, files[i])
<a name="l01067"></a>01067             dest = <span class="keywordtype">None</span>
<a name="l01068"></a>01068             <span class="keywordflow">if</span> restore_files <span class="keywordflow">and</span> len(restore_files):
<a name="l01069"></a>01069                 dest = Ontap.build_name(volume_name, restore_files[i])
<a name="l01070"></a>01070             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.snapshot_restore_file(snapshot_name, src, dest)
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     @handle_ontap_errors
<a name="l01073"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a92729940c719c36671ee2735d804fcbb">01073</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a92729940c719c36671ee2735d804fcbb">fs_snapshot_restore</a>(self, fs, snapshot, files, restore_files,
<a name="l01074"></a>01074                             all_files=<span class="keyword">False</span>, flags=0):
<a name="l01075"></a>01075         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l01076"></a>01076 <span class="stringliteral">        Restores a FS or files on a FS.</span>
<a name="l01077"></a>01077 <span class="stringliteral">        Note: Restoring an individual file is a O(n) operation, i.e. time it</span>
<a name="l01078"></a>01078 <span class="stringliteral">        takes to restore a file depends on the file size.  Reverting an entire</span>
<a name="l01079"></a>01079 <span class="stringliteral">        FS is O(1).  Try to avoid restoring individual files from a snapshot.</span>
<a name="l01080"></a>01080 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01081"></a>01081         <span class="keywordflow">if</span> files <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> all_files:
<a name="l01082"></a>01082             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.snapshot_restore_volume(fs.name, snapshot.name)
<a name="l01083"></a>01083             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01084"></a>01084         <span class="keywordflow">elif</span> files:
<a name="l01085"></a>01085             <span class="keywordflow">if</span> restore_files <span class="keywordflow">and</span> len(files) != len(restore_files):
<a name="l01086"></a>01086                 <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT,
<a name="l01087"></a>01087                                <span class="stringliteral">&quot;num files != num restore_files&quot;</span>)
<a name="l01088"></a>01088 
<a name="l01089"></a>01089             self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a4038db1d1a61a98ae8801ea95afd6a8c">_ss_restore_files</a>(fs.name, snapshot.name, files,
<a name="l01090"></a>01090                                    restore_files)
<a name="l01091"></a>01091             <span class="keywordflow">return</span> <span class="stringliteral">&quot;%s@%d&quot;</span> % (Ontap.SS_JOB, len(files))
<a name="l01092"></a>01092         <span class="keywordflow">else</span>:
<a name="l01093"></a>01093             <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT,
<a name="l01094"></a>01094                            <span class="stringliteral">&quot;Invalid parameter combination&quot;</span>)
<a name="l01095"></a>01095 
<a name="l01096"></a>01096     @handle_ontap_errors
<a name="l01097"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad2367a3f41af5450dfb672309a74e399">01097</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ad2367a3f41af5450dfb672309a74e399">export_auth</a>(self, flags=0):
<a name="l01098"></a>01098         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l01099"></a>01099 <span class="stringliteral">        Returns the types of authentication that are available for NFS</span>
<a name="l01100"></a>01100 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01101"></a>01101         <span class="keywordflow">return</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.export_auth_types()
<a name="l01102"></a>01102 
<a name="l01103"></a>01103     @staticmethod
<a name="l01104"></a>01104     <span class="keyword">def </span>_get_group(access_group, e):
<a name="l01105"></a>01105         rc = []
<a name="l01106"></a>01106 
<a name="l01107"></a>01107         <span class="keywordflow">if</span> access_group <span class="keywordflow">in</span> e:
<a name="l01108"></a>01108             <span class="keywordflow">for</span> r <span class="keywordflow">in</span> na.to_list(e[access_group][<span class="stringliteral">&apos;exports-hostname-info&apos;</span>]):
<a name="l01109"></a>01109                 <span class="keywordflow">if</span> <span class="stringliteral">&apos;all-hosts&apos;</span> <span class="keywordflow">in</span> r:
<a name="l01110"></a>01110                     <span class="keywordflow">if</span> r[<span class="stringliteral">&apos;all-hosts&apos;</span>] == <span class="stringliteral">&apos;true&apos;</span>:
<a name="l01111"></a>01111                         rc.append(<span class="stringliteral">&apos;*&apos;</span>)
<a name="l01112"></a>01112                 <span class="keywordflow">else</span>:
<a name="l01113"></a>01113                     rc.append(r[<span class="stringliteral">&apos;name&apos;</span>])
<a name="l01114"></a>01114         <span class="keywordflow">return</span> rc
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     @staticmethod
<a name="l01117"></a>01117     <span class="keyword">def </span>_get_value(key, e):
<a name="l01118"></a>01118         <span class="keywordflow">if</span> key <span class="keywordflow">in</span> e:
<a name="l01119"></a>01119             <span class="keywordflow">return</span> e[key]
<a name="l01120"></a>01120         <span class="keywordflow">else</span>:
<a name="l01121"></a>01121             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01122"></a>01122 
<a name="l01123"></a>01123     @staticmethod
<a name="l01124"></a>01124     <span class="keyword">def </span>_get_volume_id(volumes, vol_name):
<a name="l01125"></a>01125         <span class="keywordflow">for</span> v <span class="keywordflow">in</span> volumes:
<a name="l01126"></a>01126             <span class="keywordflow">if</span> v.name == vol_name:
<a name="l01127"></a>01127                 <span class="keywordflow">return</span> v.id
<a name="l01128"></a>01128         <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;Volume not found in volumes:&quot;</span> +
<a name="l01129"></a>01129                            <span class="stringliteral">&quot;:&quot;</span>.join(volumes) + <span class="stringliteral">&quot; &quot;</span> + vol_name)
<a name="l01130"></a>01130 
<a name="l01131"></a>01131     @staticmethod
<a name="l01132"></a>01132     <span class="keyword">def </span>_get_volume_from_path(path):
<a name="l01133"></a>01133         <span class="comment">#Volume paths have the form /vol/&lt;volume name&gt;/&lt;rest of path&gt;</span>
<a name="l01134"></a>01134         <span class="keywordflow">return</span> path[5:].split(<span class="stringliteral">&apos;/&apos;</span>)[0]
<a name="l01135"></a>01135 
<a name="l01136"></a>01136     @staticmethod
<a name="l01137"></a>01137     <span class="keyword">def </span>_export(volumes, e):
<a name="l01138"></a>01138         <span class="keywordflow">if</span> <span class="stringliteral">&apos;actual-pathname&apos;</span> <span class="keywordflow">in</span> e:
<a name="l01139"></a>01139             path = e[<span class="stringliteral">&apos;actual-pathname&apos;</span>]
<a name="l01140"></a>01140             export = e[<span class="stringliteral">&apos;pathname&apos;</span>]
<a name="l01141"></a>01141         <span class="keywordflow">else</span>:
<a name="l01142"></a>01142             path = e[<span class="stringliteral">&apos;pathname&apos;</span>]
<a name="l01143"></a>01143             export = e[<span class="stringliteral">&apos;pathname&apos;</span>]
<a name="l01144"></a>01144 
<a name="l01145"></a>01145         vol_name = Ontap._get_volume_from_path(path)
<a name="l01146"></a>01146         fs_id = Ontap._get_volume_id(volumes, vol_name)
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         <span class="keywordflow">return</span> NfsExport(md5(vol_name + fs_id), fs_id, export,
<a name="l01149"></a>01149                          e[<span class="stringliteral">&apos;sec-flavor&apos;</span>][<span class="stringliteral">&apos;sec-flavor-info&apos;</span>][<span class="stringliteral">&apos;flavor&apos;</span>],
<a name="l01150"></a>01150                          Ontap._get_group(<span class="stringliteral">&apos;root&apos;</span>, e),
<a name="l01151"></a>01151                          Ontap._get_group(<span class="stringliteral">&apos;read-write&apos;</span>, e),
<a name="l01152"></a>01152                          Ontap._get_group(<span class="stringliteral">&apos;read-only&apos;</span>, e),
<a name="l01153"></a>01153                          NfsExport.ANON_UID_GID_NA, NfsExport.ANON_UID_GID_NA,
<a name="l01154"></a>01154                          <span class="keywordtype">None</span>)
<a name="l01155"></a>01155 
<a name="l01156"></a>01156     @handle_ontap_errors
<a name="l01157"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a78cec8d7471da45634f0dcd747419427">01157</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a78cec8d7471da45634f0dcd747419427">exports</a>(self, search_key=None, search_value=None, flags=0):
<a name="l01158"></a>01158         <span class="comment">#Get the file systems once and pass to _export which needs to lookup</span>
<a name="l01159"></a>01159         <span class="comment">#the file system id by name.</span>
<a name="l01160"></a>01160         v = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a236bd85213ba394f4fd2347572a16977">fs</a>()
<a name="l01161"></a>01161         <span class="keywordflow">return</span> search_property(
<a name="l01162"></a>01162             [Ontap._export(v, e) <span class="keywordflow">for</span> e <span class="keywordflow">in</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.nfs_exports()],
<a name="l01163"></a>01163             search_key, search_value)
<a name="l01164"></a>01164 
<a name="l01165"></a>01165     <span class="keyword">def </span>_get_volume_from_id(self, fs_id):
<a name="l01166"></a>01166         fs = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a236bd85213ba394f4fd2347572a16977">fs</a>()
<a name="l01167"></a>01167         <span class="keywordflow">for</span> i <span class="keywordflow">in</span> fs:
<a name="l01168"></a>01168             <span class="keywordflow">if</span> i.id == fs_id:
<a name="l01169"></a>01169                 <span class="keywordflow">return</span> i
<a name="l01170"></a>01170         <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;fs id not found in fs:&quot;</span> + fs_id)
<a name="l01171"></a>01171 
<a name="l01172"></a>01172     <span class="keyword">def </span>_current_export(self, export_path):
<a name="l01173"></a>01173         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l01174"></a>01174 <span class="stringliteral">        Checks to see if we already have this export.</span>
<a name="l01175"></a>01175 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01176"></a>01176         cur_exports = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a78cec8d7471da45634f0dcd747419427">exports</a>()
<a name="l01177"></a>01177         <span class="keywordflow">for</span> ce <span class="keywordflow">in</span> cur_exports:
<a name="l01178"></a>01178             <span class="keywordflow">if</span> ce.export_path == export_path:
<a name="l01179"></a>01179                 <span class="keywordflow">return</span> <span class="keyword">True</span>
<a name="l01180"></a>01180 
<a name="l01181"></a>01181         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     @handle_ontap_errors
<a name="l01184"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a9215d35ce1982349b00533eb8d34c5b7">01184</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a9215d35ce1982349b00533eb8d34c5b7">export_fs</a>(self, fs_id, export_path, root_list, rw_list, ro_list,
<a name="l01185"></a>01185                   anon_uid, anon_gid, auth_type, options, flags=0):
<a name="l01186"></a>01186         <span class="stringliteral">&quot;&quot;&quot;</span>
<a name="l01187"></a>01187 <span class="stringliteral">        Creates or modifies the specified export</span>
<a name="l01188"></a>01188 <span class="stringliteral">        &quot;&quot;&quot;</span>
<a name="l01189"></a>01189         <span class="comment"># NetApp does not support anon_gid setting.</span>
<a name="l01190"></a>01190         <span class="keywordflow">if</span> <span class="keywordflow">not</span> (anon_gid == -1 <span class="keywordflow">or</span> anon_gid == 0xFFFFFFFFFFFFFFFF):
<a name="l01191"></a>01191             <span class="keywordflow">raise</span> LsmError(ErrorNumber.INVALID_ARGUMENT,
<a name="l01192"></a>01192                            <span class="stringliteral">&quot;ontap plugin does not support &quot;</span>
<a name="l01193"></a>01193                            <span class="stringliteral">&quot;anon_gid setting&quot;</span>)
<a name="l01194"></a>01194 
<a name="l01195"></a>01195         <span class="comment">#Get the volume info from the fs_id</span>
<a name="l01196"></a>01196         vol = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af8f583e1a153642c07de0eebd9d0a733">_get_volume_from_id</a>(fs_id)
<a name="l01197"></a>01197 
<a name="l01198"></a>01198         <span class="comment"># API states that if export path is None the plug-in will select</span>
<a name="l01199"></a>01199         <span class="comment"># export path</span>
<a name="l01200"></a>01200         <span class="keywordflow">if</span> export_path <span class="keywordflow">is</span> <span class="keywordtype">None</span>:
<a name="l01201"></a>01201             export_path = <span class="stringliteral">&apos;/vol/&apos;</span> + vol.name
<a name="l01202"></a>01202 
<a name="l01203"></a>01203         <span class="comment">#If the export already exists we need to update the existing export</span>
<a name="l01204"></a>01204         <span class="comment">#not create a new one.</span>
<a name="l01205"></a>01205         <span class="keywordflow">if</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a49bdb2cbf8b76fc18fd17042d2a75b03">_current_export</a>(export_path):
<a name="l01206"></a>01206             method = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.nfs_export_fs_modify2
<a name="l01207"></a>01207         <span class="keywordflow">else</span>:
<a name="l01208"></a>01208             method = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.nfs_export_fs2
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         method(<span class="stringliteral">&apos;/vol/&apos;</span> + vol.name,
<a name="l01211"></a>01211                export_path,
<a name="l01212"></a>01212                ro_list,
<a name="l01213"></a>01213                rw_list,
<a name="l01214"></a>01214                root_list,
<a name="l01215"></a>01215                anon_uid,
<a name="l01216"></a>01216                auth_type)
<a name="l01217"></a>01217 
<a name="l01218"></a>01218         current_exports = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a78cec8d7471da45634f0dcd747419427">exports</a>()
<a name="l01219"></a>01219         <span class="keywordflow">for</span> e <span class="keywordflow">in</span> current_exports:
<a name="l01220"></a>01220             <span class="keywordflow">if</span> e.fs_id == fs_id <span class="keywordflow">and</span> e.export_path == export_path:
<a name="l01221"></a>01221                 <span class="keywordflow">return</span> e
<a name="l01222"></a>01222 
<a name="l01223"></a>01223         <span class="keywordflow">raise</span> LsmError(ErrorNumber.PLUGIN_BUG,
<a name="l01224"></a>01224                        <span class="stringliteral">&quot;export not created successfully!&quot;</span>)
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     @handle_ontap_errors
<a name="l01227"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac2def0a081997a2a6c6dc4c513318b4f">01227</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ac2def0a081997a2a6c6dc4c513318b4f">export_remove</a>(self, export, flags=0):
<a name="l01228"></a>01228         self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.nfs_export_remove([export.export_path])
<a name="l01229"></a>01229 
<a name="l01230"></a>01230     @handle_ontap_errors
<a name="l01231"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#afb5df2951874c3e674f8c7abfa1a991a">01231</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#afb5df2951874c3e674f8c7abfa1a991a">volume_child_dependency</a>(self, volume, flags=0):
<a name="l01232"></a>01232         <span class="keywordflow">return</span> <span class="keyword">False</span>
<a name="l01233"></a>01233 
<a name="l01234"></a>01234     @handle_ontap_errors
<a name="l01235"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae036f7ff9f3cd382280b43c892e3ea91">01235</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae036f7ff9f3cd382280b43c892e3ea91">volume_child_dependency_rm</a>(self, volume, flags=0):
<a name="l01236"></a>01236         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01237"></a>01237 
<a name="l01238"></a>01238     @handle_ontap_errors
<a name="l01239"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af3ba7cdbfa8bfab3ffd0050e05c6357e">01239</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#af3ba7cdbfa8bfab3ffd0050e05c6357e">fs_child_dependency</a>(self, fs, files=None, flags=0):
<a name="l01240"></a>01240         rc = <span class="keyword">False</span>
<a name="l01241"></a>01241 
<a name="l01242"></a>01242         <span class="comment">#TODO: Make sure file actually exists if specified</span>
<a name="l01243"></a>01243 
<a name="l01244"></a>01244         <span class="keywordflow">if</span> <span class="keywordflow">not</span> files:
<a name="l01245"></a>01245             children = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_children(fs.name)
<a name="l01246"></a>01246             <span class="keywordflow">if</span> children:
<a name="l01247"></a>01247                 rc = <span class="keyword">True</span>
<a name="l01248"></a>01248         <span class="keywordflow">return</span> rc
<a name="l01249"></a>01249 
<a name="l01250"></a>01250     @handle_ontap_errors
<a name="l01251"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae6f1b29fdc7d7384f931b6f7e78f1b24">01251</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#ae6f1b29fdc7d7384f931b6f7e78f1b24">fs_child_dependency_rm</a>(self, fs, files=None, flags=0):
<a name="l01252"></a>01252         <span class="keywordflow">if</span> files:
<a name="l01253"></a>01253             <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01254"></a>01254         <span class="keywordflow">else</span>:
<a name="l01255"></a>01255             children = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_children(fs.name)
<a name="l01256"></a>01256             <span class="keywordflow">if</span> children:
<a name="l01257"></a>01257                 <span class="keywordflow">for</span> c <span class="keywordflow">in</span> children:
<a name="l01258"></a>01258                     self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volume_split_clone(c)
<a name="l01259"></a>01259                 <span class="keywordflow">return</span> <span class="stringliteral">&quot;%s@%s&quot;</span> % (Ontap.SPLIT_JOB, <span class="stringliteral">&quot;,&quot;</span>.join(children))
<a name="l01260"></a>01260         <span class="keywordflow">return</span> <span class="keywordtype">None</span>
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     @handle_ontap_errors
<a name="l01263"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aaff72e64ca31adf18ea2b5897de86e2e">01263</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#aaff72e64ca31adf18ea2b5897de86e2e">target_ports</a>(self, search_key=None, search_value=None, flags=0):
<a name="l01264"></a>01264         tp = []
<a name="l01265"></a>01265 
<a name="l01266"></a>01266         <span class="comment">#Get all FC</span>
<a name="l01267"></a>01267         fcp = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.fcp_list()
<a name="l01268"></a>01268 
<a name="l01269"></a>01269         <span class="keywordflow">for</span> f <span class="keywordflow">in</span> fcp:
<a name="l01270"></a>01270             a = f[<span class="stringliteral">&apos;addr&apos;</span>]
<a name="l01271"></a>01271             adapter = f[<span class="stringliteral">&apos;adapter&apos;</span>]
<a name="l01272"></a>01272             tp.append(TargetPort(md5(a), TargetPort.TYPE_FC, a, a, a,
<a name="l01273"></a>01273                                  adapter, self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id))
<a name="l01274"></a>01274 
<a name="l01275"></a>01275         node_name = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.iscsi_node_name()
<a name="l01276"></a>01276         iscsi = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.iscsi_list()
<a name="l01277"></a>01277         <span class="keywordflow">for</span> i <span class="keywordflow">in</span> iscsi:
<a name="l01278"></a>01278             <span class="comment">#Get all iSCSI</span>
<a name="l01279"></a>01279             service_address = node_name
<a name="l01280"></a>01280             network_address = <span class="stringliteral">&quot;%s:%s&quot;</span> % (i[<span class="stringliteral">&apos;ip&apos;</span>], i[<span class="stringliteral">&apos;port&apos;</span>])
<a name="l01281"></a>01281             physical_address = i[<span class="stringliteral">&apos;mac&apos;</span>]
<a name="l01282"></a>01282             physical_name = i[<span class="stringliteral">&apos;interface&apos;</span>]
<a name="l01283"></a>01283             tid = md5(service_address + network_address + physical_address +
<a name="l01284"></a>01284                       physical_name)
<a name="l01285"></a>01285             tp.append(TargetPort(tid, TargetPort.TYPE_ISCSI,
<a name="l01286"></a>01286                                  service_address,
<a name="l01287"></a>01287                                  network_address,
<a name="l01288"></a>01288                                  physical_address,
<a name="l01289"></a>01289                                  physical_name,
<a name="l01290"></a>01290                                  self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a808578125fcbd16c2a14e03cf5b595b4">sys_info</a>.id))
<a name="l01291"></a>01291 
<a name="l01292"></a>01292         <span class="keywordflow">return</span> search_property(tp, search_key, search_value)
<a name="l01293"></a>01293 
<a name="l01294"></a>01294     @staticmethod
<a name="l01295"></a>01295     <span class="keyword">def </span>_raid_type_of_na_aggr(na_aggr):
<a name="l01296"></a>01296         na_raid_statuses = na_aggr[<span class="stringliteral">&apos;raid-status&apos;</span>].split(<span class="stringliteral">&apos;,&apos;</span>)
<a name="l01297"></a>01297         <span class="keywordflow">if</span> <span class="stringliteral">&apos;mixed_raid_type&apos;</span> <span class="keywordflow">in</span> na_raid_statuses:
<a name="l01298"></a>01298             <span class="keywordflow">return</span> Volume.RAID_TYPE_MIXED
<a name="l01299"></a>01299         <span class="keywordflow">elif</span> <span class="stringliteral">&apos;raid0&apos;</span> <span class="keywordflow">in</span> na_raid_statuses:
<a name="l01300"></a>01300             <span class="keywordflow">return</span> Volume.RAID_TYPE_RAID0
<a name="l01301"></a>01301         <span class="keywordflow">elif</span> <span class="stringliteral">&apos;raid4&apos;</span> <span class="keywordflow">in</span> na_raid_statuses:
<a name="l01302"></a>01302             <span class="keywordflow">return</span> Volume.RAID_TYPE_RAID4
<a name="l01303"></a>01303         <span class="keywordflow">elif</span> <span class="stringliteral">&apos;raid_dp&apos;</span> <span class="keywordflow">in</span> na_raid_statuses:
<a name="l01304"></a>01304             <span class="keywordflow">return</span> Volume.RAID_TYPE_RAID6
<a name="l01305"></a>01305         <span class="keywordflow">return</span> Volume.RAID_TYPE_UNKNOWN
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     @handle_ontap_errors
<a name="l01308"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a167642e25ed4505c71839563c08f4ea2">01308</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a167642e25ed4505c71839563c08f4ea2">volume_raid_info</a>(self, volume, flags=0):
<a name="l01309"></a>01309         na_vol_name = Ontap._get_volume_from_path(volume.pool_id)
<a name="l01310"></a>01310         na_vol = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes(volume_name=na_vol_name)
<a name="l01311"></a>01311         <span class="keywordflow">if</span> len(na_vol) == 0:
<a name="l01312"></a>01312             <span class="comment"># If parent pool not found, then this LSM volume should not exist.</span>
<a name="l01313"></a>01313             <span class="keywordflow">raise</span> LsmError(
<a name="l01314"></a>01314                 ErrorNumber.NOT_FOUND_VOLUME,
<a name="l01315"></a>01315                 <span class="stringliteral">&quot;Volume not found&quot;</span>)
<a name="l01316"></a>01316         <span class="keywordflow">if</span> len(na_vol) != 1:
<a name="l01317"></a>01317             <span class="keywordflow">raise</span> LsmError(
<a name="l01318"></a>01318                 ErrorNumber.PLUGIN_BUG,
<a name="l01319"></a>01319                 <span class="stringliteral">&quot;volume_raid_info(): Got 2+ na_vols from self.f.volumes() &quot;</span>
<a name="l01320"></a>01320                 <span class="stringliteral">&quot;%s&quot;</span> % na_vol)
<a name="l01321"></a>01321 
<a name="l01322"></a>01322         na_vol = na_vol[0]
<a name="l01323"></a>01323         na_aggr_name = na_vol[<span class="stringliteral">&apos;containing-aggregate&apos;</span>]
<a name="l01324"></a>01324         na_aggr = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.aggregates(aggr_name=na_aggr_name)[0]
<a name="l01325"></a>01325         raid_type = Ontap._raid_type_of_na_aggr(na_aggr)
<a name="l01326"></a>01326         disk_count = int(na_aggr[<span class="stringliteral">&apos;disk-count&apos;</span>])
<a name="l01327"></a>01327 
<a name="l01328"></a>01328         <span class="keywordflow">return</span> [
<a name="l01329"></a>01329             raid_type, Ontap._STRIP_SIZE, disk_count, Ontap._STRIP_SIZE,
<a name="l01330"></a>01330             Ontap._OPT_IO_SIZE]
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     @handle_ontap_errors
<a name="l01333"></a><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a491c490a0a0d1d9a4cf537d3330a6168">01333</a>     <span class="keyword">def </span><a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a491c490a0a0d1d9a4cf537d3330a6168">pool_member_info</a>(self, pool, flags=0):
<a name="l01334"></a>01334         <span class="keywordflow">if</span> pool.element_type &amp; Pool.ELEMENT_TYPE_VOLUME:
<a name="l01335"></a>01335             <span class="comment"># We got a NetApp volume</span>
<a name="l01336"></a>01336             raid_type = Volume.RAID_TYPE_OTHER
<a name="l01337"></a>01337             member_type = Pool.MEMBER_TYPE_POOL
<a name="l01338"></a>01338             na_vol = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.volumes(volume_name=pool.name)[0]
<a name="l01339"></a>01339             disk_ids = [na_vol[<span class="stringliteral">&apos;containing-aggregate&apos;</span>]]
<a name="l01340"></a>01340         <span class="keywordflow">else</span>:
<a name="l01341"></a>01341             <span class="comment"># We got a NetApp aggregate</span>
<a name="l01342"></a>01342             member_type = Pool.MEMBER_TYPE_DISK
<a name="l01343"></a>01343             na_aggr = self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.aggregates(aggr_name=pool.name)[0]
<a name="l01344"></a>01344             raid_type = Ontap._raid_type_of_na_aggr(na_aggr)
<a name="l01345"></a>01345             disk_ids = list(
<a name="l01346"></a>01346                 Ontap._disk_id(d)
<a name="l01347"></a>01347                 <span class="keywordflow">for</span> d <span class="keywordflow">in</span> self.<a class="code" href="classplugin_1_1ontap_1_1ontap_1_1_ontap.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.disks()
<a name="l01348"></a>01348                 <span class="keywordflow">if</span> <span class="stringliteral">&apos;aggregate&apos;</span> <span class="keywordflow">in</span> d <span class="keywordflow">and</span> d[<span class="stringliteral">&apos;aggregate&apos;</span>] == pool.name)
<a name="l01349"></a>01349 
<a name="l01350"></a>01350         <span class="keywordflow">return</span> raid_type, member_type, disk_ids
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 9 Jul 2015 for libStorageMgmt by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
